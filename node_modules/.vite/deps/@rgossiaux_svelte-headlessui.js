import "./chunk-Y3AQ37OL.js";
import {
  writable
} from "./chunk-7PIQYMUN.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  afterUpdate,
  assign,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prevent_default,
  run_all,
  safe_not_equal,
  setContext,
  set_dynamic_element_data,
  set_store_value,
  space,
  stop_propagation,
  subscribe,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-OCUJKPZN.js";
import "./chunk-3NSHJOYC.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@rgossiaux/svelte-headlessui/internal/open-closed.js
var State;
(function(State2) {
  State2[State2["Open"] = 0] = "Open";
  State2[State2["Closed"] = 1] = "Closed";
})(State || (State = {}));
var OPEN_CLOSED_CONTEXT_NAME = "headlessui-open-closed-context";
function hasOpenClosed() {
  return useOpenClosed() !== void 0;
}
function useOpenClosed() {
  return getContext(OPEN_CLOSED_CONTEXT_NAME);
}
function useOpenClosedProvider(value) {
  setContext(OPEN_CLOSED_CONTEXT_NAME, value);
}

// node_modules/@rgossiaux/svelte-headlessui/utils/match.js
function match(value, lookup, ...args) {
  if (value in lookup) {
    let returnValue = lookup[value];
    return typeof returnValue === "function" ? returnValue(...args) : returnValue;
  }
  let error = new Error(`Tried to handle "${value}" but there is no handler defined. Only defined handlers are: ${Object.keys(lookup).map((key) => `"${key}"`).join(", ")}.`);
  if (Error.captureStackTrace)
    Error.captureStackTrace(error, match);
  throw error;
}

// node_modules/@rgossiaux/svelte-headlessui/hooks/use-id.js
var id = 0;
function generateId() {
  return ++id;
}
function useId() {
  return generateId();
}

// node_modules/@rgossiaux/svelte-headlessui/hooks/use-inert-others.js
var interactables = /* @__PURE__ */ new Set();
var originals = /* @__PURE__ */ new Map();
function inert(element2) {
  element2.setAttribute("aria-hidden", "true");
  element2.inert = true;
}
function restore(element2) {
  let original = originals.get(element2);
  if (!original)
    return;
  if (original["aria-hidden"] === null)
    element2.removeAttribute("aria-hidden");
  else
    element2.setAttribute("aria-hidden", original["aria-hidden"]);
  element2.inert = original.inert;
}
function useInertOthers(container, enabled = true) {
  if (!enabled)
    return;
  if (!container)
    return;
  let element2 = container;
  interactables.add(element2);
  for (let original of originals.keys()) {
    if (original.contains(element2)) {
      restore(original);
      originals.delete(original);
    }
  }
  document.querySelectorAll("body > *").forEach((child) => {
    if (!(child instanceof HTMLElement))
      return;
    for (let interactable of interactables) {
      if (child.contains(interactable))
        return;
    }
    if (interactables.size === 1) {
      originals.set(child, {
        "aria-hidden": child.getAttribute("aria-hidden"),
        // @ts-expect-error `inert` does not exist on HTMLElement (yet!)
        inert: child.inert
      });
      inert(child);
    }
  });
  return () => {
    interactables.delete(element2);
    if (interactables.size > 0) {
      document.querySelectorAll("body > *").forEach((child) => {
        if (!(child instanceof HTMLElement))
          return;
        if (originals.has(child))
          return;
        for (let interactable of interactables) {
          if (child.contains(interactable))
            return;
        }
        originals.set(child, {
          "aria-hidden": child.getAttribute("aria-hidden"),
          // @ts-expect-error `inert` does not exist on HTMLElement (yet!)
          inert: child.inert
        });
        inert(child);
      });
    } else {
      for (let element3 of originals.keys()) {
        restore(element3);
        originals.delete(element3);
      }
    }
  };
}

// node_modules/@rgossiaux/svelte-headlessui/internal/dom-containers.js
function contains(containers, element2) {
  for (let container of containers) {
    if (container.contains(element2))
      return true;
  }
  return false;
}

// node_modules/@rgossiaux/svelte-headlessui/utils/keyboard.js
var Keys;
(function(Keys2) {
  Keys2["Space"] = " ";
  Keys2["Enter"] = "Enter";
  Keys2["Escape"] = "Escape";
  Keys2["Backspace"] = "Backspace";
  Keys2["ArrowLeft"] = "ArrowLeft";
  Keys2["ArrowUp"] = "ArrowUp";
  Keys2["ArrowRight"] = "ArrowRight";
  Keys2["ArrowDown"] = "ArrowDown";
  Keys2["Home"] = "Home";
  Keys2["End"] = "End";
  Keys2["PageUp"] = "PageUp";
  Keys2["PageDown"] = "PageDown";
  Keys2["Tab"] = "Tab";
})(Keys || (Keys = {}));

// node_modules/@rgossiaux/svelte-headlessui/utils/focus-management.js
var focusableSelector = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(false ? (
  // TODO: Remove this once JSDOM fixes the issue where an element that is
  // "hidden" can be the document.activeElement, because this is not possible
  // in real browsers.
  (selector) => `${selector}:not([tabindex='-1']):not([style*='display: none'])`
) : (selector) => `${selector}:not([tabindex='-1'])`).join(",");
var Focus;
(function(Focus3) {
  Focus3[Focus3["First"] = 1] = "First";
  Focus3[Focus3["Previous"] = 2] = "Previous";
  Focus3[Focus3["Next"] = 4] = "Next";
  Focus3[Focus3["Last"] = 8] = "Last";
  Focus3[Focus3["WrapAround"] = 16] = "WrapAround";
  Focus3[Focus3["NoScroll"] = 32] = "NoScroll";
})(Focus || (Focus = {}));
var FocusResult;
(function(FocusResult2) {
  FocusResult2[FocusResult2["Error"] = 0] = "Error";
  FocusResult2[FocusResult2["Overflow"] = 1] = "Overflow";
  FocusResult2[FocusResult2["Success"] = 2] = "Success";
  FocusResult2[FocusResult2["Underflow"] = 3] = "Underflow";
})(FocusResult || (FocusResult = {}));
var Direction;
(function(Direction2) {
  Direction2[Direction2["Previous"] = -1] = "Previous";
  Direction2[Direction2["Next"] = 1] = "Next";
})(Direction || (Direction = {}));
function getFocusableElements(container = document.body) {
  if (container == null)
    return [];
  return Array.from(container.querySelectorAll(focusableSelector));
}
var FocusableMode;
(function(FocusableMode2) {
  FocusableMode2[FocusableMode2["Strict"] = 0] = "Strict";
  FocusableMode2[FocusableMode2["Loose"] = 1] = "Loose";
})(FocusableMode || (FocusableMode = {}));
function isFocusableElement(element2, mode = FocusableMode.Strict) {
  if (element2 === document.body)
    return false;
  return match(mode, {
    [FocusableMode.Strict]() {
      return element2.matches(focusableSelector);
    },
    [FocusableMode.Loose]() {
      let next = element2;
      while (next !== null) {
        if (next.matches(focusableSelector))
          return true;
        next = next.parentElement;
      }
      return false;
    }
  });
}
function focusElement(element2) {
  element2 == null ? void 0 : element2.focus({ preventScroll: true });
}
function focusIn(container, focus) {
  let elements = Array.isArray(container) ? container.slice().sort((a, b) => {
    let position = a.compareDocumentPosition(b);
    if (position & Node.DOCUMENT_POSITION_FOLLOWING)
      return -1;
    if (position & Node.DOCUMENT_POSITION_PRECEDING)
      return 1;
    return 0;
  }) : getFocusableElements(container);
  let active = document.activeElement;
  let direction = (() => {
    if (focus & (Focus.First | Focus.Next))
      return Direction.Next;
    if (focus & (Focus.Previous | Focus.Last))
      return Direction.Previous;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })();
  let startIndex = (() => {
    if (focus & Focus.First)
      return 0;
    if (focus & Focus.Previous)
      return Math.max(0, elements.indexOf(active)) - 1;
    if (focus & Focus.Next)
      return Math.max(0, elements.indexOf(active)) + 1;
    if (focus & Focus.Last)
      return elements.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })();
  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {};
  let offset = 0;
  let total = elements.length;
  let next = void 0;
  do {
    if (offset >= total || offset + total <= 0)
      return FocusResult.Error;
    let nextIdx = startIndex + offset;
    if (focus & Focus.WrapAround) {
      nextIdx = (nextIdx + total) % total;
    } else {
      if (nextIdx < 0)
        return FocusResult.Underflow;
      if (nextIdx >= total)
        return FocusResult.Overflow;
    }
    next = elements[nextIdx];
    next == null ? void 0 : next.focus(focusOptions);
    offset += direction;
  } while (next !== document.activeElement);
  if (!next.hasAttribute("tabindex"))
    next.setAttribute("tabindex", "0");
  return FocusResult.Success;
}

// node_modules/@rgossiaux/svelte-headlessui/components/focus-trap/FocusTrap.svelte
var { console: console_1, window: window_1 } = globals;
function create_fragment(ctx) {
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "keydown",
            /*handleWindowKeyDown*/
            ctx[0],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "focus",
            /*handleWindowFocus*/
            ctx[1],
            true,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FocusTrap", slots, []);
  let { containers } = $$props;
  let { enabled = true } = $$props;
  let { options = {} } = $$props;
  let restoreElement = typeof window !== "undefined" ? document.activeElement : null;
  let previousActiveElement = null;
  async function handleFocus() {
    if (!enabled)
      return;
    if (containers.size !== 1)
      return;
    let { initialFocus } = options;
    await tick();
    let activeElement = document.activeElement;
    if (initialFocus) {
      if (initialFocus === activeElement) {
        return;
      }
    } else if (contains(containers, activeElement)) {
      return;
    }
    restoreElement = activeElement;
    if (initialFocus) {
      focusElement(initialFocus);
    } else {
      let couldFocus = false;
      for (let container of containers) {
        let result = focusIn(container, Focus.First);
        if (result === FocusResult.Success) {
          couldFocus = true;
          break;
        }
      }
      if (!couldFocus)
        console.warn("There are no focusable elements inside the <FocusTrap />");
    }
    previousActiveElement = document.activeElement;
  }
  function restore2() {
    focusElement(restoreElement);
    restoreElement = null;
    previousActiveElement = null;
  }
  onMount(handleFocus);
  let destroying = false;
  onDestroy(() => {
    destroying = true;
    restore2();
  });
  function handleWindowKeyDown(event) {
    if (!enabled)
      return;
    if (event.key !== Keys.Tab)
      return;
    if (!document.activeElement)
      return;
    if (containers.size !== 1)
      return;
    event.preventDefault();
    for (let element2 of containers) {
      let result = focusIn(element2, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround);
      if (result === FocusResult.Success) {
        previousActiveElement = document.activeElement;
        break;
      }
    }
  }
  function handleWindowFocus(event) {
    if (event.target === window.document.body) {
      return;
    }
    if (!enabled)
      return;
    if (containers.size !== 1)
      return;
    if (destroying)
      return;
    let previous = previousActiveElement;
    if (!previous)
      return;
    let toElement = event.target;
    if (toElement && toElement instanceof HTMLElement) {
      if (!contains(containers, toElement)) {
        event.preventDefault();
        event.stopPropagation();
        focusElement(previous);
      } else {
        previousActiveElement = toElement;
        focusElement(toElement);
      }
    } else {
      focusElement(previousActiveElement);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (containers === void 0 && !("containers" in $$props || $$self.$$.bound[$$self.$$.props["containers"]])) {
      console_1.warn("<FocusTrap> was created without expected prop 'containers'");
    }
  });
  const writable_props = ["containers", "enabled", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<FocusTrap> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("containers" in $$props2)
      $$invalidate(2, containers = $$props2.containers);
    if ("enabled" in $$props2)
      $$invalidate(3, enabled = $$props2.enabled);
    if ("options" in $$props2)
      $$invalidate(4, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    Keys,
    focusElement,
    focusIn,
    Focus,
    FocusResult,
    contains,
    onMount,
    onDestroy,
    tick,
    containers,
    enabled,
    options,
    restoreElement,
    previousActiveElement,
    handleFocus,
    restore: restore2,
    destroying,
    handleWindowKeyDown,
    handleWindowFocus
  });
  $$self.$inject_state = ($$props2) => {
    if ("containers" in $$props2)
      $$invalidate(2, containers = $$props2.containers);
    if ("enabled" in $$props2)
      $$invalidate(3, enabled = $$props2.enabled);
    if ("options" in $$props2)
      $$invalidate(4, options = $$props2.options);
    if ("restoreElement" in $$props2)
      restoreElement = $$props2.restoreElement;
    if ("previousActiveElement" in $$props2)
      previousActiveElement = $$props2.previousActiveElement;
    if ("destroying" in $$props2)
      destroying = $$props2.destroying;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*enabled, containers*/
    12) {
      $:
        enabled && containers ? handleFocus() : restore2();
    }
  };
  return [handleWindowKeyDown, handleWindowFocus, containers, enabled, options];
}
var FocusTrap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { containers: 2, enabled: 3, options: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FocusTrap",
      options,
      id: create_fragment.name
    });
  }
  get containers() {
    throw new Error("<FocusTrap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containers(value) {
    throw new Error("<FocusTrap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error("<FocusTrap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error("<FocusTrap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<FocusTrap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<FocusTrap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FocusTrap_default = FocusTrap;

// node_modules/@rgossiaux/svelte-headlessui/internal/StackContextProvider.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var StackMessage;
(function(StackMessage2) {
  StackMessage2[StackMessage2["Add"] = 0] = "Add";
  StackMessage2[StackMessage2["Remove"] = 1] = "Remove";
})(StackMessage || (StackMessage = {}));
var STACK_CONTEXT_NAME = "headlessui-stack-context";
function instance2($$self, $$props, $$invalidate) {
  let _cleanup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StackContextProvider", slots, ["default"]);
  let { onUpdate } = $$props;
  let { element: element2 } = $$props;
  function notify(...args) {
    onUpdate == null ? void 0 : onUpdate(...args);
    parentUpdate == null ? void 0 : parentUpdate(...args);
  }
  let parentUpdate = getContext(STACK_CONTEXT_NAME);
  setContext(STACK_CONTEXT_NAME, notify);
  onDestroy(() => {
    if (_cleanup) {
      _cleanup();
    }
  });
  $$self.$$.on_mount.push(function() {
    if (onUpdate === void 0 && !("onUpdate" in $$props || $$self.$$.bound[$$self.$$.props["onUpdate"]])) {
      console.warn("<StackContextProvider> was created without expected prop 'onUpdate'");
    }
    if (element2 === void 0 && !("element" in $$props || $$self.$$.bound[$$self.$$.props["element"]])) {
      console.warn("<StackContextProvider> was created without expected prop 'element'");
    }
  });
  const writable_props = ["onUpdate", "element"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<StackContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("onUpdate" in $$props2)
      $$invalidate(0, onUpdate = $$props2.onUpdate);
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    StackMessage,
    STACK_CONTEXT_NAME,
    getContext,
    onDestroy,
    setContext,
    onUpdate,
    element: element2,
    notify,
    parentUpdate,
    _cleanup
  });
  $$self.$inject_state = ($$props2) => {
    if ("onUpdate" in $$props2)
      $$invalidate(0, onUpdate = $$props2.onUpdate);
    if ("element" in $$props2)
      $$invalidate(1, element2 = $$props2.element);
    if ("parentUpdate" in $$props2)
      parentUpdate = $$props2.parentUpdate;
    if ("_cleanup" in $$props2)
      $$invalidate(2, _cleanup = $$props2._cleanup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*_cleanup, element*/
    6) {
      $:
        $$invalidate(2, _cleanup = (() => {
          if (_cleanup) {
            _cleanup();
          }
          if (!element2)
            return null;
          let savedElement = element2;
          notify(StackMessage.Add, savedElement);
          return () => notify(StackMessage.Remove, savedElement);
        })());
    }
  };
  return [onUpdate, element2, _cleanup, $$scope, slots];
}
var StackContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { onUpdate: 0, element: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StackContextProvider",
      options,
      id: create_fragment2.name
    });
  }
  get onUpdate() {
    throw new Error("<StackContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onUpdate(value) {
    throw new Error("<StackContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<StackContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<StackContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StackContextProvider_default = StackContextProvider;

// node_modules/@rgossiaux/svelte-headlessui/components/description/DescriptionProvider.svelte
var get_default_slot_changes = (dirty) => ({ describedby: dirty & /*$contextStore*/
1 });
var get_default_slot_context = (ctx) => ({
  describedby: (
    /*$contextStore*/
    ctx[0].descriptionIds
  )
});
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $contextStore*/
        33)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var DESCRIPTION_CONTEXT_NAME = "headlessui-description-context";
function useDescriptionContext() {
  return getContext(DESCRIPTION_CONTEXT_NAME);
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "slotProps"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DescriptionProvider", slots, ["default"]);
  let { name } = $$props;
  let { slotProps = {} } = $$props;
  let descriptionIds = [];
  let contextStore = writable({
    name,
    slotProps,
    props: $$restProps,
    register
  });
  validate_store(contextStore, "contextStore");
  component_subscribe($$self, contextStore, (value) => $$invalidate(0, $contextStore = value));
  setContext(DESCRIPTION_CONTEXT_NAME, contextStore);
  function register(value) {
    $$invalidate(4, descriptionIds = [...descriptionIds, value]);
    return () => {
      $$invalidate(4, descriptionIds = descriptionIds.filter((descriptionId) => descriptionId !== value));
    };
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<DescriptionProvider> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("slotProps" in $$new_props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DESCRIPTION_CONTEXT_NAME,
    useDescriptionContext,
    getContext,
    setContext,
    writable,
    name,
    slotProps,
    descriptionIds,
    contextStore,
    register,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("descriptionIds" in $$props)
      $$invalidate(4, descriptionIds = $$new_props.descriptionIds);
    if ("contextStore" in $$props)
      $$invalidate(1, contextStore = $$new_props.contextStore);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      contextStore.set({
        name,
        slotProps,
        props: $$restProps,
        register,
        descriptionIds: descriptionIds.length > 0 ? descriptionIds.join(" ") : void 0
      });
  };
  return [$contextStore, contextStore, name, slotProps, descriptionIds, $$scope, slots];
}
var DescriptionProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { name: 2, slotProps: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DescriptionProvider",
      options,
      id: create_fragment3.name
    });
  }
  get name() {
    throw new Error("<DescriptionProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<DescriptionProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotProps() {
    throw new Error("<DescriptionProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotProps(value) {
    throw new Error("<DescriptionProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DescriptionProvider_default = DescriptionProvider;

// node_modules/@rgossiaux/svelte-headlessui/internal/ForcePortalRootContext.svelte
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var FORCE_PORTAL_ROOT_CONTEXT_NAME = "headlessui-force-portal-root-context";
function usePortalRoot() {
  return getContext(FORCE_PORTAL_ROOT_CONTEXT_NAME);
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ForcePortalRootContext", slots, ["default"]);
  let { force } = $$props;
  setContext(FORCE_PORTAL_ROOT_CONTEXT_NAME, writable(force));
  $$self.$$.on_mount.push(function() {
    if (force === void 0 && !("force" in $$props || $$self.$$.bound[$$self.$$.props["force"]])) {
      console.warn("<ForcePortalRootContext> was created without expected prop 'force'");
    }
  });
  const writable_props = ["force"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ForcePortalRootContext> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("force" in $$props2)
      $$invalidate(0, force = $$props2.force);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    FORCE_PORTAL_ROOT_CONTEXT_NAME,
    usePortalRoot,
    force
  });
  $$self.$inject_state = ($$props2) => {
    if ("force" in $$props2)
      $$invalidate(0, force = $$props2.force);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [force, $$scope, slots];
}
var ForcePortalRootContext = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { force: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ForcePortalRootContext",
      options,
      id: create_fragment4.name
    });
  }
  get force() {
    throw new Error("<ForcePortalRootContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set force(value) {
    throw new Error("<ForcePortalRootContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ForcePortalRootContext_default = ForcePortalRootContext;

// node_modules/@rgossiaux/svelte-headlessui/components/portal/PortalGroup.svelte
function create_fragment5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var PORTAL_GROUP_CONTEXT_NAME = "headlessui-portal-group-context";
function usePortalGroupContext() {
  return getContext(PORTAL_GROUP_CONTEXT_NAME);
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PortalGroup", slots, ["default"]);
  let { target } = $$props;
  let targetStore = writable(target);
  setContext(PORTAL_GROUP_CONTEXT_NAME, targetStore);
  $$self.$$.on_mount.push(function() {
    if (target === void 0 && !("target" in $$props || $$self.$$.bound[$$self.$$.props["target"]])) {
      console.warn("<PortalGroup> was created without expected prop 'target'");
    }
  });
  const writable_props = ["target"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PortalGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    PORTAL_GROUP_CONTEXT_NAME,
    usePortalGroupContext,
    target,
    targetStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("targetStore" in $$props2)
      $$invalidate(3, targetStore = $$props2.targetStore);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*target*/
    1) {
      $:
        targetStore.set(target);
    }
  };
  return [target, $$scope, slots];
}
var PortalGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { target: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PortalGroup",
      options,
      id: create_fragment5.name
    });
  }
  get target() {
    throw new Error("<PortalGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<PortalGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PortalGroup_default = PortalGroup;

// node_modules/@rgossiaux/svelte-headlessui/hooks/use-portal.js
function portal(element2, target) {
  if (target) {
    target.append(element2);
  }
  return {
    update(newTarget) {
      target = newTarget;
      newTarget.append(element2);
    },
    destroy() {
      var _a;
      if (target == null ? void 0 : target.contains(element2)) {
        target.removeChild(element2);
      }
      if (target && target.childNodes.length <= 0) {
        (_a = target.parentElement) == null ? void 0 : _a.removeChild(target);
      }
    }
  };
}

// node_modules/@rgossiaux/svelte-headlessui/components/portal/Portal.svelte
var file = "node_modules\\@rgossiaux\\svelte-headlessui\\components\\portal\\Portal.svelte";
function create_fragment6(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file, 33, 0, 1349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(
          null,
          div,
          /*target*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*target*/
      1)
        portal_action.update.call(
          null,
          /*target*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let target;
  let $groupTarget;
  let $forceInRoot;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let forceInRoot = usePortalRoot();
  validate_store(forceInRoot, "forceInRoot");
  component_subscribe($$self, forceInRoot, (value) => $$invalidate(4, $forceInRoot = value));
  let groupTarget = usePortalGroupContext();
  validate_store(groupTarget, "groupTarget");
  component_subscribe($$self, groupTarget, (value) => $$invalidate(3, $groupTarget = value));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Portal> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    usePortalGroupContext,
    usePortalRoot,
    portal,
    tick,
    forceInRoot,
    groupTarget,
    target,
    $groupTarget,
    $forceInRoot
  });
  $$self.$inject_state = ($$props2) => {
    if ("forceInRoot" in $$props2)
      $$invalidate(1, forceInRoot = $$props2.forceInRoot);
    if ("groupTarget" in $$props2)
      $$invalidate(2, groupTarget = $$props2.groupTarget);
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$forceInRoot, $groupTarget*/
    24) {
      $:
        $$invalidate(0, target = (() => {
          if (!(forceInRoot && $forceInRoot) && groupTarget !== void 0 && $groupTarget !== null)
            return $groupTarget;
          if (typeof window === "undefined")
            return null;
          let existingRoot = document.getElementById("headlessui-portal-root");
          if (existingRoot)
            return existingRoot;
          let root = document.createElement("div");
          root.setAttribute("id", "headlessui-portal-root");
          tick().then(() => {
            if (root !== document.body.lastChild) {
              document.body.appendChild(root);
            }
          });
          return document.body.appendChild(root);
        })());
    }
  };
  return [target, forceInRoot, groupTarget, $groupTarget, $forceInRoot, $$scope, slots];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment6.name
    });
  }
};
var Portal_default = Portal;

// node_modules/@rgossiaux/svelte-headlessui/internal/forwardEventsBuilder.js
var MODIFIER_DIVIDER = "!";
var modifierRegex = new RegExp(`^[^${MODIFIER_DIVIDER}]+(?:${MODIFIER_DIVIDER}(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$`);
function forwardEventsBuilder(component, except = []) {
  let $on;
  let events = [];
  component.$on = (fullEventType, callback) => {
    let eventType = fullEventType;
    let destructor = () => {
    };
    for (let exception of except) {
      if (typeof exception === "string" && exception === eventType) {
        const callbacks = component.$$.callbacks[eventType] || (component.$$.callbacks[eventType] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      if (typeof exception === "object" && exception["name"] === eventType) {
        let oldCallback = callback;
        callback = (...props) => {
          if (!(typeof exception === "object" && exception["shouldExclude"]())) {
            oldCallback(...props);
          }
        };
      }
    }
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events.push([eventType, callback]);
    }
    return () => {
      destructor();
    };
  };
  function forward(e) {
    bubble(component, e);
  }
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    $on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let handler = callback;
      let options = false;
      const modifierMatch = eventType.match(modifierRegex);
      if (modifierMatch) {
        const parts = eventType.split(MODIFIER_DIVIDER);
        eventType = parts[0];
        const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
        if (eventOptions.passive) {
          options = options || {};
          options.passive = true;
        }
        if (eventOptions.nonpassive) {
          options = options || {};
          options.passive = false;
        }
        if (eventOptions.capture) {
          options = options || {};
          options.capture = true;
        }
        if (eventOptions.once) {
          options = options || {};
          options.once = true;
        }
        if (eventOptions.preventDefault) {
          handler = prevent_default(handler);
        }
        if (eventOptions.stopPropagation) {
          handler = stop_propagation(handler);
        }
      }
      const off = listen(node, eventType, handler, options);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!(eventType in forwardDestructors)) {
        forwardDestructors[eventType] = listen(node, eventType, forward);
      }
      return destructor;
    };
    for (let i = 0; i < events.length; i++) {
      $on(events[i][0], events[i][1]);
    }
    return {
      destroy: () => {
        for (let i = 0; i < destructors.length; i++) {
          destructors[i]();
        }
        for (let entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}

// node_modules/@rgossiaux/svelte-headlessui/internal/elements/index.js
var components = [
  "a",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "dd",
  "dl",
  "dt",
  "div",
  "em",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "i",
  "input",
  "label",
  "li",
  "main",
  "nav",
  "ol",
  "p",
  "section",
  "span",
  "strong",
  "ul"
];
function isValidElement(element2) {
  return !(typeof element2 === "string" && !components.includes(element2));
}

// node_modules/@rgossiaux/svelte-headlessui/hooks/use-actions.js
function useActions(node, actions) {
  let actionReturns = [];
  if (actions) {
    for (let i = 0; i < actions.length; i++) {
      const actionEntry = actions[i];
      const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action(node, actionEntry[1]));
      } else {
        actionReturns.push(action(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (actions2) {
        for (let i = 0; i < actions2.length; i++) {
          const returnEntry = actionReturns[i];
          if (returnEntry && returnEntry.update) {
            const actionEntry = actions2[i];
            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
              returnEntry.update(actionEntry[1]);
            } else {
              returnEntry.update();
            }
          }
        }
      }
    },
    destroy() {
      for (let i = 0; i < actionReturns.length; i++) {
        const returnEntry = actionReturns[i];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}

// node_modules/@rgossiaux/svelte-headlessui/types.js
var Features;
(function(Features2) {
  Features2[Features2["None"] = 0] = "None";
  Features2[Features2["RenderStrategy"] = 1] = "RenderStrategy";
  Features2[Features2["Static"] = 2] = "Static";
})(Features || (Features = {}));

// node_modules/@rgossiaux/svelte-headlessui/utils/Render.svelte
var { Error: Error_1 } = globals;
var file2 = "node_modules\\@rgossiaux\\svelte-headlessui\\utils\\Render.svelte";
function create_if_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*as*/
    ctx2[1] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(56:0) {#if show}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let switch_instance;
  let updating_el;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        .../*use*/
        ctx[2],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    /*$$restProps*/
    ctx[7],
    /*propsWeControl*/
    ctx[3],
    { hidden: (
      /*hidden*/
      ctx[4] || void 0
    ) }
  ];
  function switch_instance_el_binding(value) {
    ctx[20](value);
  }
  var switch_value = (
    /*as*/
    ctx[1]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (
      /*el*/
      ctx2[0] !== void 0
    ) {
      switch_instance_props.el = /*el*/
      ctx2[0];
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "el", switch_instance_el_binding));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*use, forwardEvents, $$restProps, propsWeControl, hidden, undefined*/
      220 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*use, forwardEvents*/
        68 && {
          use: [
            .../*use*/
            ctx2[2],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        ),
        dirty & /*propsWeControl*/
        8 && get_spread_object(
          /*propsWeControl*/
          ctx2[3]
        ),
        dirty & /*hidden, undefined*/
        16 && { hidden: (
          /*hidden*/
          ctx2[4] || void 0
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      2097152) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*el*/
      1) {
        updating_el = true;
        switch_instance_changes.el = /*el*/
        ctx2[0];
        add_flush_callback(() => updating_el = false);
      }
      if (dirty & /*as*/
      2 && switch_value !== (switch_value = /*as*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "el", switch_instance_el_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(69:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: '(57:2) {#if typeof as === \\"string\\"}',
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(70:4) <svelte:component       this={as}       bind:el       use={[...use, forwardEvents]}       {...$$restProps}       {...propsWeControl}       hidden={hidden || undefined}     >",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_hidden_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let svelte_element_levels = [
    /*$$restProps*/
    ctx[7],
    /*propsWeControl*/
    ctx[3],
    {
      hidden: svelte_element_hidden_value = /*hidden*/
      ctx[4] || void 0
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file2, 57, 4, 2019);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[19](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svelte_element,
            /*use*/
            ctx[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, svelte_element))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        dirty & /*propsWeControl*/
        8 && /*propsWeControl*/
        ctx2[3],
        (!current || dirty & /*hidden*/
        16 && svelte_element_hidden_value !== (svelte_element_hidden_value = /*hidden*/
        ctx2[4] || void 0)) && { hidden: svelte_element_hidden_value }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(58:4) <svelte:element       this={as}       bind:this={el}       use:useActions={use}       use:forwardEvents       {...$$restProps}       {...propsWeControl}       hidden={hidden || undefined}     >",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*show*/
    ctx[5] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*show*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*show*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var RenderStrategy;
(function(RenderStrategy2) {
  RenderStrategy2[RenderStrategy2["Unmount"] = 0] = "Unmount";
  RenderStrategy2[RenderStrategy2["Hidden"] = 1] = "Hidden";
})(RenderStrategy || (RenderStrategy = {}));
function instance7($$self, $$props, $$invalidate) {
  let computedClass;
  let computedStyle;
  let show;
  let hidden;
  let propsWeControl;
  const omit_props_names = [
    "name",
    "as",
    "slotProps",
    "el",
    "use",
    "visible",
    "features",
    "unmount",
    "static",
    "class",
    "style"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { name } = $$props;
  let { as } = $$props;
  let { slotProps } = $$props;
  let { el = null } = $$props;
  let { use = [] } = $$props;
  let { visible = true } = $$props;
  let { features = Features.None } = $$props;
  let { unmount = true } = $$props;
  let { static: static_ = false } = $$props;
  let { class: classProp = void 0 } = $$props;
  let { style = void 0 } = $$props;
  if (!as) {
    throw new Error(`<${name}> did not provide an \`as\` value to <Render>`);
  }
  if (!isValidElement(as)) {
    throw new Error(`<${name}> has an invalid or unsupported \`as\` prop: ${as}`);
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Render> was created without expected prop 'name'");
    }
    if (as === void 0 && !("as" in $$props || $$self.$$.bound[$$self.$$.props["as"]])) {
      console.warn("<Render> was created without expected prop 'as'");
    }
    if (slotProps === void 0 && !("slotProps" in $$props || $$self.$$.bound[$$self.$$.props["slotProps"]])) {
      console.warn("<Render> was created without expected prop 'slotProps'");
    }
  });
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  function switch_instance_el_binding(value) {
    el = value;
    $$invalidate(0, el);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(8, name = $$new_props.name);
    if ("as" in $$new_props)
      $$invalidate(1, as = $$new_props.as);
    if ("slotProps" in $$new_props)
      $$invalidate(9, slotProps = $$new_props.slotProps);
    if ("el" in $$new_props)
      $$invalidate(0, el = $$new_props.el);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("visible" in $$new_props)
      $$invalidate(10, visible = $$new_props.visible);
    if ("features" in $$new_props)
      $$invalidate(11, features = $$new_props.features);
    if ("unmount" in $$new_props)
      $$invalidate(12, unmount = $$new_props.unmount);
    if ("static" in $$new_props)
      $$invalidate(13, static_ = $$new_props.static);
    if ("class" in $$new_props)
      $$invalidate(14, classProp = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(15, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    isValidElement,
    get_current_component,
    RenderStrategy,
    useActions,
    forwardEventsBuilder,
    Features,
    forwardEvents,
    name,
    as,
    slotProps,
    el,
    use,
    visible,
    features,
    unmount,
    static_,
    classProp,
    style,
    propsWeControl,
    hidden,
    computedStyle,
    computedClass,
    show
  });
  $$self.$inject_state = ($$new_props) => {
    if ("name" in $$props)
      $$invalidate(8, name = $$new_props.name);
    if ("as" in $$props)
      $$invalidate(1, as = $$new_props.as);
    if ("slotProps" in $$props)
      $$invalidate(9, slotProps = $$new_props.slotProps);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("visible" in $$props)
      $$invalidate(10, visible = $$new_props.visible);
    if ("features" in $$props)
      $$invalidate(11, features = $$new_props.features);
    if ("unmount" in $$props)
      $$invalidate(12, unmount = $$new_props.unmount);
    if ("static_" in $$props)
      $$invalidate(13, static_ = $$new_props.static_);
    if ("classProp" in $$props)
      $$invalidate(14, classProp = $$new_props.classProp);
    if ("style" in $$props)
      $$invalidate(15, style = $$new_props.style);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
    if ("hidden" in $$props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("computedStyle" in $$props)
      $$invalidate(16, computedStyle = $$new_props.computedStyle);
    if ("computedClass" in $$props)
      $$invalidate(17, computedClass = $$new_props.computedClass);
    if ("show" in $$props)
      $$invalidate(5, show = $$new_props.show);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*classProp, slotProps*/
    16896) {
      $:
        $$invalidate(17, computedClass = typeof classProp === "function" ? classProp(slotProps) : classProp);
    }
    if ($$self.$$.dirty & /*style, slotProps*/
    33280) {
      $:
        $$invalidate(16, computedStyle = typeof style === "function" ? style(slotProps) : style);
    }
    if ($$self.$$.dirty & /*visible, features, static_, unmount*/
    15360) {
      $:
        $$invalidate(5, show = visible || features & Features.Static && static_ || !(features & Features.RenderStrategy && unmount));
    }
    if ($$self.$$.dirty & /*visible, features, static_, unmount*/
    15360) {
      $:
        $$invalidate(4, hidden = !visible && !(features & Features.Static && static_) && features & Features.RenderStrategy && !unmount);
    }
    if ($$self.$$.dirty & /*computedClass, computedStyle, hidden*/
    196624) {
      $:
        $$invalidate(3, propsWeControl = {
          class: computedClass,
          style: `${computedStyle ?? ""}${hidden ? " display: none" : ""}` || void 0
        });
    }
    if ($$self.$$.dirty & /*propsWeControl*/
    8) {
      $:
        if (propsWeControl.style === void 0) {
          delete propsWeControl.style;
        }
    }
  };
  return [
    el,
    as,
    use,
    propsWeControl,
    hidden,
    show,
    forwardEvents,
    $$restProps,
    name,
    slotProps,
    visible,
    features,
    unmount,
    static_,
    classProp,
    style,
    computedStyle,
    computedClass,
    slots,
    svelte_element_binding,
    switch_instance_el_binding,
    $$scope
  ];
}
var Render = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      name: 8,
      as: 1,
      slotProps: 9,
      el: 0,
      use: 2,
      visible: 10,
      features: 11,
      unmount: 12,
      static: 13,
      class: 14,
      style: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render",
      options,
      id: create_fragment7.name
    });
  }
  get name() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotProps() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotProps(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get features() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set features(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unmount() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unmount(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get static() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set static(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Render_default = Render;

// node_modules/@rgossiaux/svelte-headlessui/components/dialog/Dialog.svelte
var { Error: Error_12, window: window_12 } = globals;
var get_default_slot_spread_changes = (dirty) => dirty & /*slotProps*/
64;
var get_default_slot_changes2 = (dirty) => ({});
var get_default_slot_context2 = (ctx) => ({ .../*slotProps*/
ctx[6] });
function create_default_slot_6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        134217792)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            get_default_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: '(221:12) <Render               {...{ ...$$restProps, ...propsWeControl }}               {as}               {slotProps}               use={[...use, forwardEvents]}               name={\\"Dialog\\"}               bind:el={internalDialogRef}               aria-describedby={describedby}               on:click={handleClick}               {visible}               features={Features.RenderStrategy | Features.Static}             >',
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[14],
      .../*propsWeControl*/
      ctx[7]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[6]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[9]
      ]
    },
    { name: "Dialog" },
    {
      "aria-describedby": (
        /*describedby*/
        ctx[30]
      )
    },
    { visible: (
      /*visible*/
      ctx[8]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  function render_el_binding(value) {
    ctx[25](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot_6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*internalDialogRef*/
    ctx[3] !== void 0
  ) {
    render_props.el = /*internalDialogRef*/
    ctx[3];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on("click", handleClick);
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents, describedby, visible, Features*/
      1073759171 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        16512 && {
          .../*$$restProps*/
          ctx2[14],
          .../*propsWeControl*/
          ctx2[7]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        64 && { slotProps: (
          /*slotProps*/
          ctx2[6]
        ) },
        dirty & /*use, forwardEvents*/
        514 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[9]
          ]
        },
        render_spread_levels[4],
        dirty & /*describedby*/
        1073741824 && {
          "aria-describedby": (
            /*describedby*/
            ctx2[30]
          )
        },
        dirty & /*visible*/
        256 && { visible: (
          /*visible*/
          ctx2[8]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      134217792) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*internalDialogRef*/
      8) {
        updating_el = true;
        render_changes.el = /*internalDialogRef*/
        ctx2[3];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: '(216:10) <DescriptionProvider             name={\\"DialogDescription\\"}             {slotProps}             let:describedby           >',
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let descriptionprovider;
  let current;
  descriptionprovider = new DescriptionProvider_default({
    props: {
      name: "DialogDescription",
      slotProps: (
        /*slotProps*/
        ctx[6]
      ),
      $$slots: {
        default: [
          create_default_slot_5,
          ({ describedby }) => ({ 30: describedby }),
          ({ describedby }) => describedby ? 1073741824 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(descriptionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(descriptionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(descriptionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const descriptionprovider_changes = {};
      if (dirty & /*slotProps*/
      64)
        descriptionprovider_changes.slotProps = /*slotProps*/
        ctx2[6];
      if (dirty & /*$$scope, $$restProps, propsWeControl, as, slotProps, use, describedby, visible, internalDialogRef*/
      1207976395) {
        descriptionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      descriptionprovider.$set(descriptionprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(descriptionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(descriptionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(descriptionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(215:8) <ForcePortalRootContext force={false}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let forceportalrootcontext;
  let current;
  forceportalrootcontext = new ForcePortalRootContext_default({
    props: {
      force: false,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(forceportalrootcontext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(forceportalrootcontext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(forceportalrootcontext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const forceportalrootcontext_changes = {};
      if (dirty & /*$$scope, slotProps, $$restProps, propsWeControl, as, use, visible, internalDialogRef*/
      134234571) {
        forceportalrootcontext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      forceportalrootcontext.$set(forceportalrootcontext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(forceportalrootcontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(forceportalrootcontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(forceportalrootcontext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(214:6) <PortalGroup target={internalDialogRef}>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let portalgroup;
  let current;
  portalgroup = new PortalGroup_default({
    props: {
      target: (
        /*internalDialogRef*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(portalgroup.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portalgroup.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portalgroup, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const portalgroup_changes = {};
      if (dirty & /*internalDialogRef*/
      8)
        portalgroup_changes.target = /*internalDialogRef*/
        ctx2[3];
      if (dirty & /*$$scope, slotProps, $$restProps, propsWeControl, as, use, visible, internalDialogRef*/
      134234571) {
        portalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portalgroup.$set(portalgroup_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portalgroup.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portalgroup.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portalgroup, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(213:4) <Portal>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let portal2;
  let current;
  portal2 = new Portal_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const portal_changes = {};
      if (dirty & /*$$scope, internalDialogRef, slotProps, $$restProps, propsWeControl, as, use, visible*/
      134234571) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(212:2) <ForcePortalRootContext force={true}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let forceportalrootcontext;
  let current;
  forceportalrootcontext = new ForcePortalRootContext_default({
    props: {
      force: true,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(forceportalrootcontext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(forceportalrootcontext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(forceportalrootcontext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const forceportalrootcontext_changes = {};
      if (dirty & /*$$scope, internalDialogRef, slotProps, $$restProps, propsWeControl, as, use, visible*/
      134234571) {
        forceportalrootcontext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      forceportalrootcontext.$set(forceportalrootcontext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(forceportalrootcontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(forceportalrootcontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(forceportalrootcontext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(198:0) <StackContextProvider   element={internalDialogRef}   onUpdate={(message, element) => {     return match(message, {       [StackMessage.Add]() {         containers = new Set([...containers, element]);       },       [StackMessage.Remove]() {         containers.delete(element);         containers = new Set([...containers]);       },     });   }} >",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let focustrap;
  let t;
  let stackcontextprovider;
  let current;
  let mounted;
  let dispose;
  focustrap = new FocusTrap_default({
    props: {
      containers: (
        /*containers*/
        ctx[5]
      ),
      enabled: (
        /*enabled*/
        ctx[4]
      ),
      options: { initialFocus: (
        /*initialFocus*/
        ctx[2]
      ) }
    },
    $$inline: true
  });
  stackcontextprovider = new StackContextProvider_default({
    props: {
      element: (
        /*internalDialogRef*/
        ctx[3]
      ),
      onUpdate: (
        /*func*/
        ctx[26]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(focustrap.$$.fragment);
      t = space();
      create_component(stackcontextprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(focustrap.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(stackcontextprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(focustrap, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(stackcontextprovider, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_12,
            "mousedown",
            /*handleWindowMousedown*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_12,
            "keydown",
            /*handleWindowKeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const focustrap_changes = {};
      if (dirty & /*containers*/
      32)
        focustrap_changes.containers = /*containers*/
        ctx2[5];
      if (dirty & /*enabled*/
      16)
        focustrap_changes.enabled = /*enabled*/
        ctx2[4];
      if (dirty & /*initialFocus*/
      4)
        focustrap_changes.options = { initialFocus: (
          /*initialFocus*/
          ctx2[2]
        ) };
      focustrap.$set(focustrap_changes);
      const stackcontextprovider_changes = {};
      if (dirty & /*internalDialogRef*/
      8)
        stackcontextprovider_changes.element = /*internalDialogRef*/
        ctx2[3];
      if (dirty & /*containers*/
      32)
        stackcontextprovider_changes.onUpdate = /*func*/
        ctx2[26];
      if (dirty & /*$$scope, internalDialogRef, slotProps, $$restProps, propsWeControl, as, use, visible*/
      134234571) {
        stackcontextprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      stackcontextprovider.$set(stackcontextprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(focustrap.$$.fragment, local);
      transition_in(stackcontextprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(focustrap.$$.fragment, local);
      transition_out(stackcontextprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(focustrap, detaching);
      destroy_component(stackcontextprovider, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var DialogStates;
(function(DialogStates2) {
  DialogStates2[DialogStates2["Open"] = 0] = "Open";
  DialogStates2[DialogStates2["Closed"] = 1] = "Closed";
})(DialogStates || (DialogStates = {}));
var DIALOG_CONTEXT_NAME = "headlessui-dialog-context";
function useDialogContext(component) {
  let context = getContext(DIALOG_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${component} /> is missing a parent <Dialog /> component.`);
  }
  return context;
}
function handleClick(e) {
  let event = e;
  event.stopPropagation();
}
function instance8($$self, $$props, $$invalidate) {
  let dialogState;
  let visible;
  let enabled;
  let _cleanup;
  let _cleanupScrollLock;
  let _cleanupClose;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "open", "initialFocus"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $openClosedState;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dialog", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { open = void 0 } = $$props;
  let { initialFocus = null } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component(), ["close"]);
  const dispatch = createEventDispatcher();
  let containers = /* @__PURE__ */ new Set();
  let openClosedState = useOpenClosed();
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(23, $openClosedState = value));
  let internalDialogRef = null;
  const id2 = `headlessui-dialog-${useId()}`;
  onDestroy(() => {
    if (_cleanup) {
      _cleanup();
    }
  });
  let titleId;
  let api = writable({
    titleId,
    dialogState,
    setTitleId(id3) {
      if (titleId === id3)
        return;
      $$invalidate(16, titleId = id3);
    },
    close() {
      dispatch("close", false);
    }
  });
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(22, $api = value));
  setContext(DIALOG_CONTEXT_NAME, api);
  async function handleWindowMousedown(event) {
    let target = event.target;
    if (dialogState !== DialogStates.Open)
      return;
    if (containers.size !== 1)
      return;
    if (contains(containers, target))
      return;
    $api.close();
    await tick();
    target == null ? void 0 : target.focus();
  }
  function handleWindowKeydown(event) {
    if (event.key !== Keys.Escape)
      return;
    if (dialogState !== DialogStates.Open)
      return;
    if (containers.size > 1)
      return;
    event.preventDefault();
    event.stopPropagation();
    $api.close();
  }
  let mounted = false;
  onMount(() => $$invalidate(17, mounted = true));
  onDestroy(() => {
    if (_cleanupScrollLock) {
      _cleanupScrollLock();
    }
  });
  onDestroy(() => {
    if (_cleanupClose) {
      _cleanupClose();
    }
  });
  function render_el_binding(value) {
    internalDialogRef = value;
    $$invalidate(3, internalDialogRef);
  }
  const func = (message, element2) => {
    return match(message, {
      [StackMessage.Add]() {
        $$invalidate(5, containers = /* @__PURE__ */ new Set([...containers, element2]));
      },
      [StackMessage.Remove]() {
        containers.delete(element2);
        $$invalidate(5, containers = /* @__PURE__ */ new Set([...containers]));
      }
    });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("open" in $$new_props)
      $$invalidate(15, open = $$new_props.open);
    if ("initialFocus" in $$new_props)
      $$invalidate(2, initialFocus = $$new_props.initialFocus);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    createEventDispatcher,
    tick,
    onDestroy,
    onMount,
    DialogStates,
    DIALOG_CONTEXT_NAME,
    useDialogContext,
    State,
    useOpenClosed,
    writable,
    match,
    useId,
    useInertOthers,
    contains,
    Keys,
    FocusTrap: FocusTrap_default,
    StackContextProvider: StackContextProvider_default,
    StackMessage,
    DescriptionProvider: DescriptionProvider_default,
    ForcePortalRootContext: ForcePortalRootContext_default,
    Portal: Portal_default,
    PortalGroup: PortalGroup_default,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    Features,
    as,
    use,
    open,
    initialFocus,
    forwardEvents,
    dispatch,
    containers,
    openClosedState,
    internalDialogRef,
    id: id2,
    titleId,
    api,
    handleWindowMousedown,
    handleWindowKeydown,
    mounted,
    handleClick,
    slotProps,
    dialogState,
    propsWeControl,
    _cleanupClose,
    _cleanupScrollLock,
    _cleanup,
    enabled,
    visible,
    $api,
    $openClosedState
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("open" in $$props)
      $$invalidate(15, open = $$new_props.open);
    if ("initialFocus" in $$props)
      $$invalidate(2, initialFocus = $$new_props.initialFocus);
    if ("containers" in $$props)
      $$invalidate(5, containers = $$new_props.containers);
    if ("openClosedState" in $$props)
      $$invalidate(10, openClosedState = $$new_props.openClosedState);
    if ("internalDialogRef" in $$props)
      $$invalidate(3, internalDialogRef = $$new_props.internalDialogRef);
    if ("titleId" in $$props)
      $$invalidate(16, titleId = $$new_props.titleId);
    if ("api" in $$props)
      $$invalidate(11, api = $$new_props.api);
    if ("mounted" in $$props)
      $$invalidate(17, mounted = $$new_props.mounted);
    if ("slotProps" in $$props)
      $$invalidate(6, slotProps = $$new_props.slotProps);
    if ("dialogState" in $$props)
      $$invalidate(18, dialogState = $$new_props.dialogState);
    if ("propsWeControl" in $$props)
      $$invalidate(7, propsWeControl = $$new_props.propsWeControl);
    if ("_cleanupClose" in $$props)
      $$invalidate(19, _cleanupClose = $$new_props._cleanupClose);
    if ("_cleanupScrollLock" in $$props)
      $$invalidate(20, _cleanupScrollLock = $$new_props._cleanupScrollLock);
    if ("_cleanup" in $$props)
      $$invalidate(21, _cleanup = $$new_props._cleanup);
    if ("enabled" in $$props)
      $$invalidate(4, enabled = $$new_props.enabled);
    if ("visible" in $$props)
      $$invalidate(8, visible = $$new_props.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open, $openClosedState*/
    8421376) {
      $: {
        $$invalidate(15, open = open === void 0 && openClosedState !== void 0 ? match($openClosedState, {
          [State.Open]: true,
          [State.Closed]: false
        }) : open);
        let hasOpen = open !== void 0 || openClosedState !== void 0;
        if (!hasOpen) {
          throw new Error(`You forgot to provide an \`open\` prop to the \`Dialog\` component.`);
        }
        if (typeof open !== "boolean") {
          throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${open}`);
        }
      }
    }
    if ($$self.$$.dirty & /*open*/
    32768) {
      $:
        $$invalidate(18, dialogState = open ? DialogStates.Open : DialogStates.Closed);
    }
    if ($$self.$$.dirty & /*$openClosedState, dialogState*/
    8650752) {
      $:
        $$invalidate(8, visible = openClosedState !== void 0 ? $openClosedState === State.Open : dialogState === DialogStates.Open);
    }
    if ($$self.$$.dirty & /*dialogState*/
    262144) {
      $:
        $$invalidate(4, enabled = dialogState === DialogStates.Open);
    }
    if ($$self.$$.dirty & /*_cleanup, internalDialogRef, enabled*/
    2097176) {
      $:
        $$invalidate(21, _cleanup = (() => {
          if (_cleanup) {
            _cleanup();
          }
          return useInertOthers(internalDialogRef, enabled);
        })());
    }
    if ($$self.$$.dirty & /*titleId, dialogState*/
    327680) {
      $:
        api.update((obj) => {
          return { ...obj, titleId, dialogState };
        });
    }
    if ($$self.$$.dirty & /*_cleanupScrollLock, dialogState, mounted*/
    1441792) {
      $:
        $$invalidate(20, _cleanupScrollLock = (() => {
          if (_cleanupScrollLock) {
            _cleanupScrollLock();
          }
          if (dialogState !== DialogStates.Open)
            return;
          if (!mounted)
            return;
          let overflow = document.documentElement.style.overflow;
          let paddingRight = document.documentElement.style.paddingRight;
          let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
          document.documentElement.style.overflow = "hidden";
          document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
          return () => {
            document.documentElement.style.overflow = overflow;
            document.documentElement.style.paddingRight = paddingRight;
          };
        })());
    }
    if ($$self.$$.dirty & /*_cleanupClose, dialogState, internalDialogRef, $api*/
    4980744) {
      $:
        $$invalidate(19, _cleanupClose = (() => {
          if (_cleanupClose) {
            _cleanupClose();
          }
          if (dialogState !== DialogStates.Open)
            return;
          let container = internalDialogRef;
          if (!container)
            return;
          let observer = new IntersectionObserver((entries) => {
            for (let entry of entries) {
              if (entry.boundingClientRect.x === 0 && entry.boundingClientRect.y === 0 && entry.boundingClientRect.width === 0 && entry.boundingClientRect.height === 0) {
                $api.close();
              }
            }
          });
          observer.observe(container);
          return () => observer.disconnect();
        })());
    }
    if ($$self.$$.dirty & /*dialogState, titleId*/
    327680) {
      $:
        $$invalidate(7, propsWeControl = {
          id: id2,
          role: "dialog",
          "aria-modal": dialogState === DialogStates.Open ? true : void 0,
          "aria-labelledby": titleId
        });
    }
    if ($$self.$$.dirty & /*open*/
    32768) {
      $:
        $$invalidate(6, slotProps = { open });
    }
  };
  return [
    as,
    use,
    initialFocus,
    internalDialogRef,
    enabled,
    containers,
    slotProps,
    propsWeControl,
    visible,
    forwardEvents,
    openClosedState,
    api,
    handleWindowMousedown,
    handleWindowKeydown,
    $$restProps,
    open,
    titleId,
    mounted,
    dialogState,
    _cleanupClose,
    _cleanupScrollLock,
    _cleanup,
    $api,
    $openClosedState,
    slots,
    render_el_binding,
    func,
    $$scope
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { as: 0, use: 1, open: 15, initialFocus: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment8.name
    });
  }
  get as() {
    throw new Error_12("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_12("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_12("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_12("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error_12("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error_12("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialFocus() {
    throw new Error_12("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialFocus(value) {
    throw new Error_12("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dialog_default = Dialog;

// node_modules/@rgossiaux/svelte-headlessui/components/dialog/DialogTitle.svelte
var get_default_slot_spread_changes2 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes3 = (dirty) => ({});
var get_default_slot_context3 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        516)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            get_default_slot_spread_changes2(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(27:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"DialogTitle\\"} >',
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[6],
      .../*propsWeControl*/
      ctx[3]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[4]
      ]
    },
    { name: "DialogTitle" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      95 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        72 && {
          .../*$$restProps*/
          ctx2[6],
          .../*propsWeControl*/
          ctx2[3]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        18 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[4]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      516) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogTitle", slots, ["default"]);
  let { as = "h2" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useDialogContext("DialogTitle");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(7, $api = value));
  let id2 = `headlessui-dialog-title-${useId()}`;
  onMount(() => {
    $api.setTitleId(id2);
    return () => $api.setTitleId(void 0);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DialogStates,
    useDialogContext,
    useId,
    onMount,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    api,
    id: id2,
    slotProps,
    propsWeControl,
    $api
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(5, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(10, id2 = $$new_props.id);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    128) {
      $:
        $$invalidate(2, slotProps = {
          open: $api.dialogState === DialogStates.Open
        });
    }
  };
  $:
    $$invalidate(3, propsWeControl = { id: id2 });
  return [
    as,
    use,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    $$restProps,
    $api,
    slots,
    $$scope
  ];
}
var DialogTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogTitle",
      options,
      id: create_fragment9.name
    });
  }
  get as() {
    throw new Error("<DialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<DialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<DialogTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<DialogTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogTitle_default = DialogTitle;

// node_modules/@rgossiaux/svelte-headlessui/components/dialog/DialogOverlay.svelte
var get_default_slot_spread_changes3 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes4 = (dirty) => ({});
var get_default_slot_context4 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        1028)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            get_default_slot_spread_changes3(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(31:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"DialogOverlay\\"}   on:click={handleClick} >',
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[7],
      .../*propsWeControl*/
      ctx[3]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[4]
      ]
    },
    { name: "DialogOverlay" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  render.$on(
    "click",
    /*handleClick*/
    ctx[6]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      159 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        136 && {
          .../*$$restProps*/
          ctx2[7],
          .../*propsWeControl*/
          ctx2[3]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        18 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[4]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      1028) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DialogOverlay", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useDialogContext("DialogOverlay");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(8, $api = value));
  let id2 = `headlessui-dialog-overlay-${useId()}`;
  function handleClick2(e) {
    let event = e;
    if (event.target !== event.currentTarget)
      return;
    event.preventDefault();
    event.stopPropagation();
    $api.close();
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DialogStates,
    useDialogContext,
    useId,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    api,
    id: id2,
    handleClick: handleClick2,
    slotProps,
    propsWeControl,
    $api
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(5, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(11, id2 = $$new_props.id);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    256) {
      $:
        $$invalidate(2, slotProps = {
          open: $api.dialogState === DialogStates.Open
        });
    }
  };
  $:
    $$invalidate(3, propsWeControl = { id: id2, "aria-hidden": true });
  return [
    as,
    use,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    handleClick2,
    $$restProps,
    $api,
    slots,
    $$scope
  ];
}
var DialogOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DialogOverlay",
      options,
      id: create_fragment10.name
    });
  }
  get as() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<DialogOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<DialogOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DialogOverlay_default = DialogOverlay;

// node_modules/@rgossiaux/svelte-headlessui/components/description/Description.svelte
var { Error: Error_13 } = globals;
var get_default_slot_spread_changes4 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes5 = (dirty) => ({});
var get_default_slot_context5 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        520)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            get_default_slot_spread_changes4(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(19:0) <Render   name={\\"Description\\"}   {...$$restProps}   {as}   {slotProps}   {...$contextStore?.props}   {id}   use={[...use, forwardEvents]} >',
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  var _a;
  let render;
  let current;
  const render_spread_levels = [
    { name: "Description" },
    /*$$restProps*/
    ctx[7],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    /*$contextStore*/
    (_a = ctx[2]) == null ? void 0 : _a.props,
    { id: (
      /*id*/
      ctx[5]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[4]
      ]
    }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2;
      const render_changes = dirty & /*$$restProps, as, slotProps, $contextStore, id, use, forwardEvents*/
      191 ? get_spread_update(render_spread_levels, [
        render_spread_levels[0],
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*$contextStore*/
        4 && get_spread_object(
          /*$contextStore*/
          (_a2 = ctx2[2]) == null ? void 0 : _a2.props
        ),
        dirty & /*id*/
        32 && { id: (
          /*id*/
          ctx2[5]
        ) },
        dirty & /*use, forwardEvents*/
        18 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[4]
          ]
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      520) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Description", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { as = "p" } = $$props;
  let { use = [] } = $$props;
  const id2 = `headlessui-description-${useId()}`;
  let contextStore = useDescriptionContext();
  validate_store(contextStore, "contextStore");
  component_subscribe($$self, contextStore, (value) => $$invalidate(2, $contextStore = value));
  if (!contextStore) {
    throw new Error("You used a <Description /> component, but it is not inside a relevant parent.");
  }
  onMount(() => $contextStore == null ? void 0 : $contextStore.register(id2));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useId,
    forwardEventsBuilder,
    Render: Render_default,
    onMount,
    get_current_component,
    useDescriptionContext,
    forwardEvents,
    as,
    use,
    id: id2,
    contextStore,
    slotProps,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("contextStore" in $$props)
      $$invalidate(6, contextStore = $$new_props.contextStore);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$contextStore*/
    4) {
      $:
        $$invalidate(3, slotProps = $contextStore.slotProps || {});
    }
  };
  return [
    as,
    use,
    $contextStore,
    slotProps,
    forwardEvents,
    id2,
    contextStore,
    $$restProps,
    slots,
    $$scope
  ];
}
var Description = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Description",
      options,
      id: create_fragment11.name
    });
  }
  get as() {
    throw new Error_13("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_13("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_13("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_13("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Description_default = Description;

// node_modules/@rgossiaux/svelte-headlessui/components/disclosure/Disclosure.svelte
var { Error: Error_14 } = globals;
var get_default_slot_spread_changes5 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes6 = (dirty) => ({});
var get_default_slot_context6 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        4100)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            get_default_slot_spread_changes5(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(88:0) <Render   {...$$restProps}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"Disclosure\\"} >',
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[7],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { name: "Disclosure" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, slotProps, use, forwardEvents*/
      143 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      4100) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var DisclosureStates;
(function(DisclosureStates2) {
  DisclosureStates2[DisclosureStates2["Open"] = 0] = "Open";
  DisclosureStates2[DisclosureStates2["Closed"] = 1] = "Closed";
})(DisclosureStates || (DisclosureStates = {}));
var DISCLOSURE_CONTEXT_NAME = "headlessui-disclosure-context";
function useDisclosureContext(component) {
  let context = getContext(DISCLOSURE_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${component} /> is missing a parent <Disclosure /> component.`);
  }
  return context;
}
function instance12($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use", "defaultOpen"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $openClosedState;
  let $buttonStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Disclosure", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { defaultOpen = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let buttonId = `headlessui-disclosure-button-${useId()}`;
  let panelId = `headlessui-disclosure-panel-${useId()}`;
  let disclosureState = defaultOpen ? DisclosureStates.Open : DisclosureStates.Closed;
  let panelStore = writable(null);
  let buttonStore = writable(null);
  validate_store(buttonStore, "buttonStore");
  component_subscribe($$self, buttonStore, (value) => $$invalidate(14, $buttonStore = value));
  let api = writable({
    buttonId,
    panelId,
    disclosureState,
    panelStore,
    buttonStore,
    toggleDisclosure() {
      $$invalidate(9, disclosureState = match(disclosureState, {
        [DisclosureStates.Open]: DisclosureStates.Closed,
        [DisclosureStates.Closed]: DisclosureStates.Open
      }));
    },
    closeDisclosure() {
      if (disclosureState === DisclosureStates.Closed)
        return;
      $$invalidate(9, disclosureState = DisclosureStates.Closed);
    },
    close(focusableElement) {
      $api.closeDisclosure();
      let restoreElement = (() => {
        if (!focusableElement)
          return $buttonStore;
        if (focusableElement instanceof HTMLElement)
          return focusableElement;
        return $buttonStore;
      })();
      restoreElement == null ? void 0 : restoreElement.focus();
    }
  });
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(10, $api = value));
  setContext(DISCLOSURE_CONTEXT_NAME, api);
  function computeOpenClosedState(disclosureState2) {
    return match(disclosureState2, {
      [DisclosureStates.Open]: State.Open,
      [DisclosureStates.Closed]: State.Closed
    });
  }
  let openClosedState = writable(computeOpenClosedState(disclosureState));
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(13, $openClosedState = value));
  useOpenClosedProvider(openClosedState);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("defaultOpen" in $$new_props)
      $$invalidate(8, defaultOpen = $$new_props.defaultOpen);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    getContext,
    setContext,
    DisclosureStates,
    DISCLOSURE_CONTEXT_NAME,
    useDisclosureContext,
    useId,
    match,
    State,
    useOpenClosedProvider,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    defaultOpen,
    forwardEvents,
    buttonId,
    panelId,
    disclosureState,
    panelStore,
    buttonStore,
    api,
    computeOpenClosedState,
    openClosedState,
    slotProps,
    $api,
    $openClosedState,
    $buttonStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("defaultOpen" in $$props)
      $$invalidate(8, defaultOpen = $$new_props.defaultOpen);
    if ("buttonId" in $$props)
      buttonId = $$new_props.buttonId;
    if ("panelId" in $$props)
      panelId = $$new_props.panelId;
    if ("disclosureState" in $$props)
      $$invalidate(9, disclosureState = $$new_props.disclosureState);
    if ("panelStore" in $$props)
      panelStore = $$new_props.panelStore;
    if ("buttonStore" in $$props)
      $$invalidate(4, buttonStore = $$new_props.buttonStore);
    if ("api" in $$props)
      $$invalidate(5, api = $$new_props.api);
    if ("openClosedState" in $$props)
      $$invalidate(6, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disclosureState*/
    512) {
      $:
        api.update((obj) => {
          return { ...obj, disclosureState };
        });
    }
    if ($$self.$$.dirty & /*disclosureState*/
    512) {
      $:
        set_store_value(openClosedState, $openClosedState = computeOpenClosedState(disclosureState), $openClosedState);
    }
    if ($$self.$$.dirty & /*disclosureState, $api*/
    1536) {
      $:
        $$invalidate(2, slotProps = {
          open: disclosureState === DisclosureStates.Open,
          close: $api.close
        });
    }
  };
  return [
    as,
    use,
    slotProps,
    forwardEvents,
    buttonStore,
    api,
    openClosedState,
    $$restProps,
    defaultOpen,
    disclosureState,
    $api,
    slots,
    $$scope
  ];
}
var Disclosure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { as: 0, use: 1, defaultOpen: 8 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Disclosure",
      options,
      id: create_fragment12.name
    });
  }
  get as() {
    throw new Error_14("<Disclosure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_14("<Disclosure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_14("<Disclosure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_14("<Disclosure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultOpen() {
    throw new Error_14("<Disclosure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultOpen(value) {
    throw new Error_14("<Disclosure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Disclosure_default = Disclosure;

// node_modules/@rgossiaux/svelte-headlessui/components/disclosure/DisclosurePanel.svelte
var get_default_slot_spread_changes6 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes7 = (dirty) => ({});
var get_default_slot_context7 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        32772)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            get_default_slot_spread_changes6(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: '(34:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"DisclosurePanel\\"}   bind:el={$panelStore}   {visible}   features={Features.RenderStrategy | Features.Static} >',
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[10],
      .../*propsWeControl*/
      ctx[3]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[7]
      ]
    },
    { name: "DisclosurePanel" },
    { visible: (
      /*visible*/
      ctx[4]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  function render_el_binding(value) {
    ctx[14](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$panelStore*/
    ctx[6] !== void 0
  ) {
    render_props.el = /*$panelStore*/
    ctx[6];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents, visible, Features*/
      1183 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        1032 && {
          .../*$$restProps*/
          ctx2[10],
          .../*propsWeControl*/
          ctx2[3]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        130 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[7]
          ]
        },
        render_spread_levels[4],
        dirty & /*visible*/
        16 && { visible: (
          /*visible*/
          ctx2[4]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      32772) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$panelStore*/
      64) {
        updating_el = true;
        render_changes.el = /*$panelStore*/
        ctx2[6];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var DISCLOSURE_PANEL_CONTEXT_NAME = "headlessui-disclosure-panel-context";
function usePanelContext() {
  return getContext(DISCLOSURE_PANEL_CONTEXT_NAME);
}
function instance13($$self, $$props, $$invalidate) {
  let panelStore;
  let visible;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $openClosedState;
  let $panelStore, $$unsubscribe_panelStore = noop, $$subscribe_panelStore = () => ($$unsubscribe_panelStore(), $$unsubscribe_panelStore = subscribe(panelStore, ($$value) => $$invalidate(6, $panelStore = $$value)), panelStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_panelStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DisclosurePanel", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const api = useDisclosureContext("DisclosurePanel");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(11, $api = value));
  let openClosedState = useOpenClosed();
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(12, $openClosedState = value));
  setContext(DISCLOSURE_PANEL_CONTEXT_NAME, $api.panelId);
  function render_el_binding(value) {
    $panelStore = value;
    panelStore.set($panelStore);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    DISCLOSURE_PANEL_CONTEXT_NAME,
    usePanelContext,
    useDisclosureContext,
    DisclosureStates,
    State,
    useOpenClosed,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    Features,
    as,
    use,
    forwardEvents,
    api,
    openClosedState,
    slotProps,
    propsWeControl,
    visible,
    panelStore,
    $api,
    $openClosedState,
    $panelStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("openClosedState" in $$props)
      $$invalidate(9, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
    if ("visible" in $$props)
      $$invalidate(4, visible = $$new_props.visible);
    if ("panelStore" in $$props)
      $$subscribe_panelStore($$invalidate(5, panelStore = $$new_props.panelStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    2048) {
      $:
        $$subscribe_panelStore($$invalidate(5, panelStore = $api.panelStore));
    }
    if ($$self.$$.dirty & /*$openClosedState, $api*/
    6144) {
      $:
        $$invalidate(4, visible = $openClosedState !== null ? $openClosedState === State.Open : $api.disclosureState === DisclosureStates.Open);
    }
    if ($$self.$$.dirty & /*$api*/
    2048) {
      $:
        $$invalidate(3, propsWeControl = { id: $api.panelId });
    }
    if ($$self.$$.dirty & /*$api*/
    2048) {
      $:
        $$invalidate(2, slotProps = {
          open: $api.disclosureState === DisclosureStates.Open,
          close: $api.close
        });
    }
  };
  return [
    as,
    use,
    slotProps,
    propsWeControl,
    visible,
    panelStore,
    $panelStore,
    forwardEvents,
    api,
    openClosedState,
    $$restProps,
    $api,
    $openClosedState,
    slots,
    render_el_binding,
    $$scope
  ];
}
var DisclosurePanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DisclosurePanel",
      options,
      id: create_fragment13.name
    });
  }
  get as() {
    throw new Error("<DisclosurePanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<DisclosurePanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<DisclosurePanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<DisclosurePanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DisclosurePanel_default = DisclosurePanel;

// node_modules/@rgossiaux/svelte-headlessui/utils/resolve-button-type.js
function resolveButtonType(props, ref) {
  if (props.type)
    return props.type;
  let tag = props.as ?? "button";
  if (typeof tag === "string" && tag.toLowerCase() === "button")
    return "button";
  if (ref && ref instanceof HTMLButtonElement)
    return "button";
  return void 0;
}

// node_modules/@rgossiaux/svelte-headlessui/components/disclosure/DisclosureButton.svelte
var get_default_slot_spread_changes_1 = (dirty) => dirty & /*slotProps*/
64;
var get_default_slot_changes_1 = (dirty) => ({});
var get_default_slot_context_1 = (ctx) => ({ .../*slotProps*/
ctx[6] });
var get_default_slot_spread_changes7 = (dirty) => dirty & /*slotProps*/
64;
var get_default_slot_changes8 = (dirty) => ({});
var get_default_slot_context8 = (ctx) => ({ .../*slotProps*/
ctx[6] });
function create_else_block2(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[14],
      .../*propsWeControl*/
      ctx[7]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[6]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[9]
      ]
    },
    { name: "DisclosureButton" }
  ];
  function render_el_binding_1(value) {
    ctx[21](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$ourStore*/
    ctx[4] !== void 0
  ) {
    render_props.el = /*$ourStore*/
    ctx[4];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding_1));
  render.$on(
    "click",
    /*handleClick*/
    ctx[11]
  );
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[12]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      17091 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        16512 && {
          .../*$$restProps*/
          ctx2[14],
          .../*propsWeControl*/
          ctx2[7]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        64 && { slotProps: (
          /*slotProps*/
          ctx2[6]
        ) },
        dirty & /*use, forwardEvents*/
        514 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[9]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      4194368) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$ourStore*/
      16) {
        updating_el = true;
        render_changes.el = /*$ourStore*/
        ctx2[4];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(106:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[14],
      .../*propsWeControl*/
      ctx[7]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[6]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[9]
      ]
    },
    { name: "DisclosureButton" }
  ];
  function render_el_binding(value) {
    ctx[20](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$ourStore*/
    ctx[4] !== void 0
  ) {
    render_props.el = /*$ourStore*/
    ctx[4];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[11]
  );
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      17091 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        16512 && {
          .../*$$restProps*/
          ctx2[14],
          .../*propsWeControl*/
          ctx2[7]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        64 && { slotProps: (
          /*slotProps*/
          ctx2[6]
        ) },
        dirty & /*use, forwardEvents*/
        514 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[9]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      4194368) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$ourStore*/
      16) {
        updating_el = true;
        render_changes.el = /*$ourStore*/
        ctx2[4];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(93:0) {#if isWithinPanel}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        4194368)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            get_default_slot_spread_changes_1(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(107:2) <Render     {...{ ...$$restProps, ...propsWeControl }}     {as}     {slotProps}     use={[...use, forwardEvents]}     name={\\"DisclosureButton\\"}     bind:el={$ourStore}     on:click={handleClick}     on:keydown={handleKeyDown}     on:keyup={handleKeyUp}   >',
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        4194368)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            get_default_slot_spread_changes7(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: '(94:2) <Render     {...{ ...$$restProps, ...propsWeControl }}     {as}     {slotProps}     use={[...use, forwardEvents]}     name={\\"DisclosureButton\\"}     bind:el={$ourStore}     on:click={handleClick}     on:keydown={handleKeyDown}   >',
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isWithinPanel*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let buttonStore;
  let panelStore;
  let isWithinPanel;
  let type;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $panelStore, $$unsubscribe_panelStore = noop, $$subscribe_panelStore = () => ($$unsubscribe_panelStore(), $$unsubscribe_panelStore = subscribe(panelStore, ($$value) => $$invalidate(18, $panelStore = $$value)), panelStore);
  let $ourStore, $$unsubscribe_ourStore = noop, $$subscribe_ourStore = () => ($$unsubscribe_ourStore(), $$unsubscribe_ourStore = subscribe(ourStore, ($$value) => $$invalidate(4, $ourStore = $$value)), ourStore);
  let $buttonStore, $$unsubscribe_buttonStore = noop, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(23, $buttonStore = $$value)), buttonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_panelStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ourStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DisclosureButton", slots, ["default"]);
  let { as = "button" } = $$props;
  let { use = [] } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const api = useDisclosureContext("DisclosureButton");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(17, $api = value));
  const panelContext = usePanelContext();
  let ourStore = writable(null);
  validate_store(ourStore, "ourStore");
  $$subscribe_ourStore();
  function handleClick2() {
    if (disabled)
      return;
    if (isWithinPanel) {
      $api.toggleDisclosure();
      $buttonStore == null ? void 0 : $buttonStore.focus();
    } else {
      $api.toggleDisclosure();
    }
  }
  function handleKeyDown(e) {
    if (disabled)
      return;
    let event = e;
    if (isWithinPanel) {
      switch (event.key) {
        case Keys.Space:
        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();
          $api.toggleDisclosure();
          $buttonStore == null ? void 0 : $buttonStore.focus();
          break;
      }
    } else {
      switch (event.key) {
        case Keys.Space:
        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();
          $api.toggleDisclosure();
          break;
      }
    }
  }
  function handleKeyUp(e) {
    let event = e;
    switch (event.key) {
      case Keys.Space:
        event.preventDefault();
        break;
    }
  }
  function render_el_binding(value) {
    $ourStore = value;
    ourStore.set($ourStore);
  }
  function render_el_binding_1(value) {
    $ourStore = value;
    ourStore.set($ourStore);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$new_props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useDisclosureContext,
    DisclosureStates,
    usePanelContext,
    Keys,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    writable,
    resolveButtonType,
    as,
    use,
    disabled,
    forwardEvents,
    api,
    panelContext,
    ourStore,
    handleClick: handleClick2,
    handleKeyDown,
    handleKeyUp,
    slotProps,
    type,
    isWithinPanel,
    propsWeControl,
    buttonStore,
    panelStore,
    $api,
    $panelStore,
    $ourStore,
    $buttonStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(25, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("ourStore" in $$props)
      $$subscribe_ourStore($$invalidate(5, ourStore = $$new_props.ourStore));
    if ("slotProps" in $$props)
      $$invalidate(6, slotProps = $$new_props.slotProps);
    if ("type" in $$props)
      $$invalidate(16, type = $$new_props.type);
    if ("isWithinPanel" in $$props)
      $$invalidate(2, isWithinPanel = $$new_props.isWithinPanel);
    if ("propsWeControl" in $$props)
      $$invalidate(7, propsWeControl = $$new_props.propsWeControl);
    if ("buttonStore" in $$props)
      $$subscribe_buttonStore($$invalidate(3, buttonStore = $$new_props.buttonStore));
    if ("panelStore" in $$props)
      $$subscribe_panelStore($$invalidate(8, panelStore = $$new_props.panelStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    131072) {
      $:
        $$subscribe_buttonStore($$invalidate(3, buttonStore = $api.buttonStore));
    }
    if ($$self.$$.dirty & /*$api*/
    131072) {
      $:
        $$subscribe_panelStore($$invalidate(8, panelStore = $api.panelStore));
    }
    if ($$self.$$.dirty & /*$api*/
    131072) {
      $:
        $$invalidate(2, isWithinPanel = panelContext === null ? false : panelContext === $api.panelId);
    }
    if ($$self.$$.dirty & /*isWithinPanel, buttonStore*/
    12) {
      $:
        if (!isWithinPanel)
          $$subscribe_ourStore($$invalidate(5, ourStore = buttonStore));
    }
    $:
      $$invalidate(16, type = resolveButtonType({ type: $$props.type, as }, $ourStore));
    if ($$self.$$.dirty & /*isWithinPanel, type, $api, disabled, $panelStore*/
    491524) {
      $:
        $$invalidate(7, propsWeControl = isWithinPanel ? { type } : {
          id: $api.buttonId,
          type,
          "aria-expanded": disabled ? void 0 : $api.disclosureState === DisclosureStates.Open,
          "aria-controls": $panelStore ? $api.panelId : void 0,
          disabled: disabled ? true : void 0
        });
    }
    if ($$self.$$.dirty & /*$api*/
    131072) {
      $:
        $$invalidate(6, slotProps = {
          open: $api.disclosureState === DisclosureStates.Open,
          close: $api.close
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    isWithinPanel,
    buttonStore,
    $ourStore,
    ourStore,
    slotProps,
    propsWeControl,
    panelStore,
    forwardEvents,
    api,
    handleClick2,
    handleKeyDown,
    handleKeyUp,
    $$restProps,
    disabled,
    type,
    $api,
    $panelStore,
    slots,
    render_el_binding,
    render_el_binding_1,
    $$scope
  ];
}
var DisclosureButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { as: 0, use: 1, disabled: 15 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DisclosureButton",
      options,
      id: create_fragment14.name
    });
  }
  get as() {
    throw new Error("<DisclosureButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<DisclosureButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<DisclosureButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<DisclosureButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DisclosureButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DisclosureButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DisclosureButton_default = DisclosureButton;

// node_modules/@rgossiaux/svelte-headlessui/utils/calculate-active-index.js
function assertNever(x) {
  throw new Error("Unexpected object: " + x);
}
var Focus2;
(function(Focus3) {
  Focus3[Focus3["First"] = 0] = "First";
  Focus3[Focus3["Previous"] = 1] = "Previous";
  Focus3[Focus3["Next"] = 2] = "Next";
  Focus3[Focus3["Last"] = 3] = "Last";
  Focus3[Focus3["Specific"] = 4] = "Specific";
  Focus3[Focus3["Nothing"] = 5] = "Nothing";
})(Focus2 || (Focus2 = {}));
function calculateActiveIndex(action, resolvers) {
  let items = resolvers.resolveItems();
  if (items.length <= 0)
    return null;
  let currentActiveIndex = resolvers.resolveActiveIndex();
  let activeIndex = currentActiveIndex ?? -1;
  let nextActiveIndex = (() => {
    switch (action.focus) {
      case Focus2.First:
        return items.findIndex((item) => !resolvers.resolveDisabled(item));
      case Focus2.Previous: {
        let idx = items.slice().reverse().findIndex((item, idx2, all) => {
          if (activeIndex !== -1 && all.length - idx2 - 1 >= activeIndex)
            return false;
          return !resolvers.resolveDisabled(item);
        });
        if (idx === -1)
          return idx;
        return items.length - 1 - idx;
      }
      case Focus2.Next:
        return items.findIndex((item, idx) => {
          if (idx <= activeIndex)
            return false;
          return !resolvers.resolveDisabled(item);
        });
      case Focus2.Last: {
        let idx = items.slice().reverse().findIndex((item) => !resolvers.resolveDisabled(item));
        if (idx === -1)
          return idx;
        return items.length - 1 - idx;
      }
      case Focus2.Specific:
        return items.findIndex((item) => resolvers.resolveId(item) === action.id);
      case Focus2.Nothing:
        return null;
      default:
        assertNever(action);
    }
  })();
  return nextActiveIndex === -1 ? currentActiveIndex : nextActiveIndex;
}

// node_modules/@rgossiaux/svelte-headlessui/components/listbox/Listbox.svelte
var { Error: Error_15 } = globals;
var get_default_slot_spread_changes8 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes9 = (dirty) => ({});
var get_default_slot_context9 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context9
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        262148)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            get_default_slot_spread_changes8(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: '(190:0) <Render   {...$$restProps}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"Listbox\\"} >',
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let render;
  let current;
  let mounted;
  let dispose;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[8],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { name: "Listbox" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "mousedown",
          /*handleMousedown*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, slotProps, use, forwardEvents*/
      271 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx2[8]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      262148) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var ListboxStates;
(function(ListboxStates2) {
  ListboxStates2[ListboxStates2["Open"] = 0] = "Open";
  ListboxStates2[ListboxStates2["Closed"] = 1] = "Closed";
})(ListboxStates || (ListboxStates = {}));
var LISTBOX_CONTEXT_NAME = "headlessui-listbox-context";
function useListboxContext(component) {
  let context = getContext(LISTBOX_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${component} /> is missing a parent <Listbox /> component.`);
  }
  return context;
}
function instance15($$self, $$props, $$invalidate) {
  let orientation;
  let slotProps;
  const omit_props_names = ["as", "use", "disabled", "horizontal", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $buttonRef;
  let $api;
  let $optionsRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Listbox", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { disabled = false } = $$props;
  let { horizontal = false } = $$props;
  let { value } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let listboxState = ListboxStates.Closed;
  let labelRef = writable(null);
  let buttonRef = writable(null);
  validate_store(buttonRef, "buttonRef");
  component_subscribe($$self, buttonRef, (value2) => $$invalidate(19, $buttonRef = value2));
  let optionsRef = writable(null);
  validate_store(optionsRef, "optionsRef");
  component_subscribe($$self, optionsRef, (value2) => $$invalidate(21, $optionsRef = value2));
  let options = [];
  let searchQuery = "";
  let activeOptionIndex = null;
  let api = writable({
    listboxState,
    value,
    labelRef,
    buttonRef,
    optionsRef,
    options,
    searchQuery,
    activeOptionIndex,
    disabled,
    orientation,
    closeListbox() {
      if (disabled)
        return;
      if (listboxState === ListboxStates.Closed)
        return;
      $$invalidate(12, listboxState = ListboxStates.Closed);
      $$invalidate(15, activeOptionIndex = null);
    },
    openListbox() {
      if (disabled)
        return;
      if (listboxState === ListboxStates.Open)
        return;
      $$invalidate(12, listboxState = ListboxStates.Open);
    },
    goToOption(focus, id2) {
      if (disabled)
        return;
      if (listboxState === ListboxStates.Closed)
        return;
      let nextActiveOptionIndex = calculateActiveIndex(
        focus === Focus2.Specific ? { focus: Focus2.Specific, id: id2 } : { focus },
        {
          resolveItems: () => options,
          resolveActiveIndex: () => activeOptionIndex,
          resolveId: (option) => option.id,
          resolveDisabled: (option) => option.dataRef.disabled
        }
      );
      if (searchQuery === "" && activeOptionIndex === nextActiveOptionIndex)
        return;
      $$invalidate(15, activeOptionIndex = nextActiveOptionIndex);
      $$invalidate(14, searchQuery = "");
    },
    search(value2) {
      if (disabled)
        return;
      if (listboxState === ListboxStates.Closed)
        return;
      $$invalidate(14, searchQuery += value2.toLowerCase());
      let reorderedOptions = activeOptionIndex !== null ? options.slice(activeOptionIndex + 1).concat(options.slice(0, activeOptionIndex + 1)) : options;
      let matchingOption = reorderedOptions.find((option) => !option.dataRef.disabled && option.dataRef.textValue.startsWith(searchQuery));
      let matchIdx = matchingOption ? options.indexOf(matchingOption) : -1;
      if (matchIdx === -1 || matchIdx === activeOptionIndex)
        return;
      $$invalidate(15, activeOptionIndex = matchIdx);
    },
    clearSearch() {
      if (disabled)
        return;
      if (listboxState === ListboxStates.Closed)
        return;
      if (searchQuery === "")
        return;
      $$invalidate(14, searchQuery = "");
    },
    registerOption(id2, dataRef) {
      if (!$optionsRef) {
        $$invalidate(13, options = [...options, { id: id2, dataRef }]);
        return;
      }
      let currentActiveOption = activeOptionIndex !== null ? options[activeOptionIndex] : null;
      let orderMap = Array.from($optionsRef.querySelectorAll('[id^="headlessui-listbox-option-"]')).reduce((lookup, element2, index) => Object.assign(lookup, { [element2.id]: index }), {});
      let nextOptions = [...options, { id: id2, dataRef }];
      nextOptions.sort((a, z) => orderMap[a.id] - orderMap[z.id]);
      $$invalidate(13, options = nextOptions);
      $$invalidate(15, activeOptionIndex = (() => {
        if (currentActiveOption === null)
          return null;
        return options.indexOf(currentActiveOption);
      })());
    },
    unregisterOption(id2) {
      let nextOptions = options.slice();
      let currentActiveOption = activeOptionIndex !== null ? nextOptions[activeOptionIndex] : null;
      let idx = nextOptions.findIndex((a) => a.id === id2);
      if (idx !== -1)
        nextOptions.splice(idx, 1);
      $$invalidate(13, options = nextOptions);
      $$invalidate(15, activeOptionIndex = (() => {
        if (idx === activeOptionIndex)
          return null;
        if (currentActiveOption === null)
          return null;
        return nextOptions.indexOf(currentActiveOption);
      })());
    },
    select(newValue) {
      if (disabled)
        return;
      $$invalidate(9, value = newValue);
    }
  });
  validate_store(api, "api");
  component_subscribe($$self, api, (value2) => $$invalidate(20, $api = value2));
  setContext(LISTBOX_CONTEXT_NAME, api);
  let openClosedState = writable(State.Closed);
  useOpenClosedProvider(openClosedState);
  function handleMousedown(event) {
    let target = event.target;
    let active = document.activeElement;
    if (listboxState !== ListboxStates.Open)
      return;
    if ($buttonRef == null ? void 0 : $buttonRef.contains(target))
      return;
    if (!($optionsRef == null ? void 0 : $optionsRef.contains(target)))
      $api.closeListbox();
    if (active !== document.body && (active == null ? void 0 : active.contains(target)))
      return;
    if (!event.defaultPrevented) {
      $buttonRef == null ? void 0 : $buttonRef.focus({ preventScroll: true });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Listbox> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("horizontal" in $$new_props)
      $$invalidate(11, horizontal = $$new_props.horizontal);
    if ("value" in $$new_props)
      $$invalidate(9, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ListboxStates,
    LISTBOX_CONTEXT_NAME,
    useListboxContext,
    Focus: Focus2,
    calculateActiveIndex,
    getContext,
    setContext,
    writable,
    match,
    State,
    useOpenClosedProvider,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    disabled,
    horizontal,
    value,
    forwardEvents,
    listboxState,
    labelRef,
    buttonRef,
    optionsRef,
    options,
    searchQuery,
    activeOptionIndex,
    api,
    openClosedState,
    handleMousedown,
    slotProps,
    orientation,
    $buttonRef,
    $api,
    $optionsRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("horizontal" in $$props)
      $$invalidate(11, horizontal = $$new_props.horizontal);
    if ("value" in $$props)
      $$invalidate(9, value = $$new_props.value);
    if ("listboxState" in $$props)
      $$invalidate(12, listboxState = $$new_props.listboxState);
    if ("labelRef" in $$props)
      labelRef = $$new_props.labelRef;
    if ("buttonRef" in $$props)
      $$invalidate(4, buttonRef = $$new_props.buttonRef);
    if ("optionsRef" in $$props)
      $$invalidate(5, optionsRef = $$new_props.optionsRef);
    if ("options" in $$props)
      $$invalidate(13, options = $$new_props.options);
    if ("searchQuery" in $$props)
      $$invalidate(14, searchQuery = $$new_props.searchQuery);
    if ("activeOptionIndex" in $$props)
      $$invalidate(15, activeOptionIndex = $$new_props.activeOptionIndex);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("openClosedState" in $$props)
      $$invalidate(23, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("orientation" in $$props)
      $$invalidate(16, orientation = $$new_props.orientation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*horizontal*/
    2048) {
      $:
        $$invalidate(16, orientation = horizontal ? "horizontal" : "vertical");
    }
    if ($$self.$$.dirty & /*listboxState*/
    4096) {
      $:
        openClosedState.set(match(listboxState, {
          [ListboxStates.Open]: State.Open,
          [ListboxStates.Closed]: State.Closed
        }));
    }
    if ($$self.$$.dirty & /*listboxState, value, options, searchQuery, activeOptionIndex, disabled, orientation*/
    128512) {
      $:
        api.update((obj) => {
          return {
            ...obj,
            listboxState,
            value,
            options,
            searchQuery,
            activeOptionIndex,
            disabled,
            orientation
          };
        });
    }
    if ($$self.$$.dirty & /*listboxState*/
    4096) {
      $:
        $$invalidate(2, slotProps = {
          open: listboxState === ListboxStates.Open
        });
    }
  };
  return [
    as,
    use,
    slotProps,
    forwardEvents,
    buttonRef,
    optionsRef,
    api,
    handleMousedown,
    $$restProps,
    value,
    disabled,
    horizontal,
    listboxState,
    options,
    searchQuery,
    activeOptionIndex,
    orientation,
    slots,
    $$scope
  ];
}
var Listbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      as: 0,
      use: 1,
      disabled: 10,
      horizontal: 11,
      value: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Listbox",
      options,
      id: create_fragment15.name
    });
  }
  get as() {
    throw new Error_15("<Listbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_15("<Listbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_15("<Listbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_15("<Listbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error_15("<Listbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error_15("<Listbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error_15("<Listbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error_15("<Listbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_15("<Listbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_15("<Listbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Listbox_default = Listbox;

// node_modules/@rgossiaux/svelte-headlessui/components/listbox/ListboxButton.svelte
var get_default_slot_spread_changes9 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes10 = (dirty) => ({});
var get_default_slot_context10 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context10
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524296)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes9(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: '(91:0) <Render   {...$$restProps}   {...propsWeControl}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"ListboxButton\\"}   bind:el={$buttonRef}   on:click={handleClick}   on:keydown={handleKeyDown}   on:keyup={handleKeyUp} >',
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[13],
    /*propsWeControl*/
    ctx[4],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[5]
      ]
    },
    { name: "ListboxButton" }
  ];
  function render_el_binding(value) {
    ctx[18](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$buttonRef*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*$buttonRef*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[12]
  );
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[10]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      8251 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        8192 && get_spread_object(
          /*$$restProps*/
          ctx2[13]
        ),
        dirty & /*propsWeControl*/
        16 && get_spread_object(
          /*propsWeControl*/
          ctx2[4]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*use, forwardEvents*/
        34 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[5]
          ]
        },
        render_spread_levels[5]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524296) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$buttonRef*/
      4) {
        updating_el = true;
        render_changes.el = /*$buttonRef*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $labelRef;
  let $optionsRef;
  let $buttonRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListboxButton", slots, ["default"]);
  let { as = "button" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useListboxContext("ListboxButton");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(14, $api = value));
  let id2 = `headlessui-listbox-button-${useId()}`;
  let buttonRef = $api.buttonRef;
  validate_store(buttonRef, "buttonRef");
  component_subscribe($$self, buttonRef, (value) => $$invalidate(2, $buttonRef = value));
  let optionsRef = $api.optionsRef;
  validate_store(optionsRef, "optionsRef");
  component_subscribe($$self, optionsRef, (value) => $$invalidate(16, $optionsRef = value));
  let labelRef = $api.labelRef;
  validate_store(labelRef, "labelRef");
  component_subscribe($$self, labelRef, (value) => $$invalidate(15, $labelRef = value));
  async function handleKeyDown(e) {
    let event = e;
    switch (event.key) {
      case Keys.Space:
      case Keys.Enter:
      case Keys.ArrowDown:
        event.preventDefault();
        $api.openListbox();
        await tick();
        $optionsRef == null ? void 0 : $optionsRef.focus({ preventScroll: true });
        if (!$api.value)
          $api.goToOption(Focus2.First);
        break;
      case Keys.ArrowUp:
        event.preventDefault();
        $api.openListbox();
        await tick();
        $optionsRef == null ? void 0 : $optionsRef.focus({ preventScroll: true });
        if (!$api.value)
          $api.goToOption(Focus2.Last);
        break;
    }
  }
  function handleKeyUp(e) {
    let event = e;
    switch (event.key) {
      case Keys.Space:
        event.preventDefault();
        break;
    }
  }
  async function handleClick2(e) {
    let event = e;
    if ($api.disabled)
      return;
    if ($api.listboxState === ListboxStates.Open) {
      $api.closeListbox();
      await tick();
      $buttonRef == null ? void 0 : $buttonRef.focus({ preventScroll: true });
    } else {
      event.preventDefault();
      $api.openListbox();
      await tick();
      $optionsRef == null ? void 0 : $optionsRef.focus({ preventScroll: true });
    }
  }
  function render_el_binding(value) {
    $buttonRef = value;
    buttonRef.set($buttonRef);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tick,
    ListboxStates,
    useListboxContext,
    useId,
    Keys,
    Focus: Focus2,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    resolveButtonType,
    as,
    use,
    forwardEvents,
    api,
    id: id2,
    buttonRef,
    optionsRef,
    labelRef,
    handleKeyDown,
    handleKeyUp,
    handleClick: handleClick2,
    slotProps,
    propsWeControl,
    $api,
    $labelRef,
    $optionsRef,
    $buttonRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(20, id2 = $$new_props.id);
    if ("buttonRef" in $$props)
      $$invalidate(7, buttonRef = $$new_props.buttonRef);
    if ("optionsRef" in $$props)
      $$invalidate(8, optionsRef = $$new_props.optionsRef);
    if ("labelRef" in $$props)
      $$invalidate(9, labelRef = $$new_props.labelRef);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, propsWeControl = {
        id: id2,
        type: resolveButtonType({ type: $$props.type, as }, $buttonRef),
        "aria-haspopup": true,
        "aria-controls": $optionsRef == null ? void 0 : $optionsRef.id,
        "aria-expanded": $api.disabled ? void 0 : $api.listboxState === ListboxStates.Open,
        "aria-labelledby": $labelRef ? [$labelRef == null ? void 0 : $labelRef.id, id2].join(" ") : void 0,
        disabled: $api.disabled === true ? true : void 0
      });
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$invalidate(3, slotProps = {
          open: $api.listboxState === ListboxStates.Open,
          disabled: $api.disabled
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    $buttonRef,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    buttonRef,
    optionsRef,
    labelRef,
    handleKeyDown,
    handleKeyUp,
    handleClick2,
    $$restProps,
    $api,
    $labelRef,
    $optionsRef,
    slots,
    render_el_binding,
    $$scope
  ];
}
var ListboxButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListboxButton",
      options,
      id: create_fragment16.name
    });
  }
  get as() {
    throw new Error("<ListboxButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<ListboxButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<ListboxButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ListboxButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListboxButton_default = ListboxButton;

// node_modules/@rgossiaux/svelte-headlessui/components/listbox/ListboxLabel.svelte
var get_default_slot_spread_changes10 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes11 = (dirty) => ({});
var get_default_slot_context11 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context11
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        16388)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            get_default_slot_spread_changes10(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: '(27:0) <Render   {...$$restProps}   {id}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"ListboxLabel\\"}   bind:el={$labelRef}   on:click={handleClick} >',
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[10],
    { id: (
      /*id*/
      ctx[5]
    ) },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[4]
      ]
    },
    { name: "ListboxLabel" }
  ];
  function render_el_binding(value) {
    ctx[13](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$labelRef*/
    ctx[3] !== void 0
  ) {
    render_props.el = /*$labelRef*/
    ctx[3];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, id, as, slotProps, use, forwardEvents*/
      1079 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx2[10]
        ),
        dirty & /*id*/
        32 && { id: (
          /*id*/
          ctx2[5]
        ) },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        18 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[4]
          ]
        },
        render_spread_levels[5]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      16388) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$labelRef*/
      8) {
        updating_el = true;
        render_changes.el = /*$labelRef*/
        ctx2[3];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $buttonRef;
  let $labelRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListboxLabel", slots, ["default"]);
  let { as = "label" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let id2 = `headlessui-listbox-label-${useId()}`;
  let api = useListboxContext("ListboxLabel");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(11, $api = value));
  let labelRef = $api.labelRef;
  validate_store(labelRef, "labelRef");
  component_subscribe($$self, labelRef, (value) => $$invalidate(3, $labelRef = value));
  let buttonRef = $api.buttonRef;
  validate_store(buttonRef, "buttonRef");
  component_subscribe($$self, buttonRef, (value) => $$invalidate(15, $buttonRef = value));
  function handleClick2() {
    $buttonRef == null ? void 0 : $buttonRef.focus({ preventScroll: true });
  }
  function render_el_binding(value) {
    $labelRef = value;
    labelRef.set($labelRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ListboxStates,
    useListboxContext,
    useId,
    Render: Render_default,
    forwardEventsBuilder,
    get_current_component,
    as,
    use,
    forwardEvents,
    id: id2,
    api,
    labelRef,
    buttonRef,
    handleClick: handleClick2,
    slotProps,
    $api,
    $buttonRef,
    $labelRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("id" in $$props)
      $$invalidate(5, id2 = $$new_props.id);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("labelRef" in $$props)
      $$invalidate(7, labelRef = $$new_props.labelRef);
    if ("buttonRef" in $$props)
      $$invalidate(8, buttonRef = $$new_props.buttonRef);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    2048) {
      $:
        $$invalidate(2, slotProps = {
          open: $api.listboxState === ListboxStates.Open,
          disabled: $api.disabled
        });
    }
  };
  return [
    as,
    use,
    slotProps,
    $labelRef,
    forwardEvents,
    id2,
    api,
    labelRef,
    buttonRef,
    handleClick2,
    $$restProps,
    $api,
    slots,
    render_el_binding,
    $$scope
  ];
}
var ListboxLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListboxLabel",
      options,
      id: create_fragment17.name
    });
  }
  get as() {
    throw new Error("<ListboxLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<ListboxLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<ListboxLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ListboxLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListboxLabel_default = ListboxLabel;

// node_modules/@rgossiaux/svelte-headlessui/components/listbox/ListboxOptions.svelte
var get_default_slot_spread_changes11 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes12 = (dirty) => ({});
var get_default_slot_context12 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_default_slot_context12
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        1048580)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            get_default_slot_spread_changes11(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: '(111:0) <Render   {...$$restProps}   {...propsWeControl}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"ListboxOptions\\"}   bind:el={$optionsRef}   on:keydown={handleKeyDown}   {visible}   features={Features.RenderStrategy | Features.Static} >',
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[13],
    /*propsWeControl*/
    ctx[4],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "ListboxOptions" },
    { visible: (
      /*visible*/
      ctx[3]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  function render_el_binding(value) {
    ctx[19](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$optionsRef*/
    ctx[5] !== void 0
  ) {
    render_props.el = /*$optionsRef*/
    ctx[5];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents, visible, Features*/
      8287 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        8192 && get_spread_object(
          /*$$restProps*/
          ctx2[13]
        ),
        dirty & /*propsWeControl*/
        16 && get_spread_object(
          /*propsWeControl*/
          ctx2[4]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        render_spread_levels[5],
        dirty & /*visible*/
        8 && { visible: (
          /*visible*/
          ctx2[3]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      1048580) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$optionsRef*/
      32) {
        updating_el = true;
        render_changes.el = /*$optionsRef*/
        ctx2[5];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let propsWeControl;
  let visible;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $usesOpenClosedState;
  let $buttonRef;
  let $labelRef;
  let $optionsRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListboxOptions", slots, ["default"]);
  let { as = "ul" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useListboxContext("ListboxOptions");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(14, $api = value));
  let id2 = `headlessui-listbox-options-${useId()}`;
  let optionsRef = $api.optionsRef;
  validate_store(optionsRef, "optionsRef");
  component_subscribe($$self, optionsRef, (value) => $$invalidate(5, $optionsRef = value));
  let buttonRef = $api.buttonRef;
  validate_store(buttonRef, "buttonRef");
  component_subscribe($$self, buttonRef, (value) => $$invalidate(16, $buttonRef = value));
  let labelRef = $api.labelRef;
  validate_store(labelRef, "labelRef");
  component_subscribe($$self, labelRef, (value) => $$invalidate(17, $labelRef = value));
  let searchDebounce = null;
  async function handleKeyDown(e) {
    let event = e;
    if (searchDebounce)
      clearTimeout(searchDebounce);
    switch (event.key) {
      case Keys.Space:
        if ($api.searchQuery !== "") {
          event.preventDefault();
          event.stopPropagation();
          return $api.search(event.key);
        }
      case Keys.Enter:
        event.preventDefault();
        event.stopPropagation();
        if ($api.activeOptionIndex !== null) {
          let { dataRef } = $api.options[$api.activeOptionIndex];
          $api.select(dataRef.value);
        }
        $api.closeListbox();
        await tick();
        $buttonRef == null ? void 0 : $buttonRef.focus({ preventScroll: true });
        break;
      case match($api.orientation, {
        vertical: Keys.ArrowDown,
        horizontal: Keys.ArrowRight
      }):
        event.preventDefault();
        event.stopPropagation();
        return $api.goToOption(Focus2.Next);
      case match($api.orientation, {
        vertical: Keys.ArrowUp,
        horizontal: Keys.ArrowLeft
      }):
        event.preventDefault();
        event.stopPropagation();
        return $api.goToOption(Focus2.Previous);
      case Keys.Home:
      case Keys.PageUp:
        event.preventDefault();
        event.stopPropagation();
        return $api.goToOption(Focus2.First);
      case Keys.End:
      case Keys.PageDown:
        event.preventDefault();
        event.stopPropagation();
        return $api.goToOption(Focus2.Last);
      case Keys.Escape:
        event.preventDefault();
        event.stopPropagation();
        $api.closeListbox();
        await tick();
        $buttonRef == null ? void 0 : $buttonRef.focus({ preventScroll: true });
        break;
      case Keys.Tab:
        event.preventDefault();
        event.stopPropagation();
        break;
      default:
        if (event.key.length === 1) {
          $api.search(event.key);
          searchDebounce = setTimeout(() => $api.clearSearch(), 350);
        }
        break;
    }
  }
  let usesOpenClosedState = useOpenClosed();
  validate_store(usesOpenClosedState, "usesOpenClosedState");
  component_subscribe($$self, usesOpenClosedState, (value) => $$invalidate(15, $usesOpenClosedState = value));
  function render_el_binding(value) {
    $optionsRef = value;
    optionsRef.set($optionsRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tick,
    ListboxStates,
    useListboxContext,
    useId,
    match,
    Keys,
    Focus: Focus2,
    State,
    useOpenClosed,
    Render: Render_default,
    forwardEventsBuilder,
    get_current_component,
    Features,
    as,
    use,
    forwardEvents,
    api,
    id: id2,
    optionsRef,
    buttonRef,
    labelRef,
    searchDebounce,
    handleKeyDown,
    usesOpenClosedState,
    slotProps,
    visible,
    propsWeControl,
    $api,
    $usesOpenClosedState,
    $buttonRef,
    $labelRef,
    $optionsRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(7, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(22, id2 = $$new_props.id);
    if ("optionsRef" in $$props)
      $$invalidate(8, optionsRef = $$new_props.optionsRef);
    if ("buttonRef" in $$props)
      $$invalidate(9, buttonRef = $$new_props.buttonRef);
    if ("labelRef" in $$props)
      $$invalidate(10, labelRef = $$new_props.labelRef);
    if ("searchDebounce" in $$props)
      searchDebounce = $$new_props.searchDebounce;
    if ("usesOpenClosedState" in $$props)
      $$invalidate(12, usesOpenClosedState = $$new_props.usesOpenClosedState);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("visible" in $$props)
      $$invalidate(3, visible = $$new_props.visible);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*$api, $labelRef, $buttonRef*/
    212992) {
      $:
        $$invalidate(4, propsWeControl = {
          "aria-activedescendant": $api.activeOptionIndex === null ? void 0 : (_a = $api.options[$api.activeOptionIndex]) == null ? void 0 : _a.id,
          "aria-labelledby": ($labelRef == null ? void 0 : $labelRef.id) ?? ($buttonRef == null ? void 0 : $buttonRef.id),
          "aria-orientation": $api.orientation,
          id: id2,
          role: "listbox",
          tabIndex: 0
        });
    }
    if ($$self.$$.dirty & /*$usesOpenClosedState, $api*/
    49152) {
      $:
        $$invalidate(3, visible = usesOpenClosedState !== void 0 ? $usesOpenClosedState === State.Open : $api.listboxState === ListboxStates.Open);
    }
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$invalidate(2, slotProps = {
          open: $api.listboxState === ListboxStates.Open
        });
    }
  };
  return [
    as,
    use,
    slotProps,
    visible,
    propsWeControl,
    $optionsRef,
    forwardEvents,
    api,
    optionsRef,
    buttonRef,
    labelRef,
    handleKeyDown,
    usesOpenClosedState,
    $$restProps,
    $api,
    $usesOpenClosedState,
    $buttonRef,
    $labelRef,
    slots,
    render_el_binding,
    $$scope
  ];
}
var ListboxOptions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListboxOptions",
      options,
      id: create_fragment18.name
    });
  }
  get as() {
    throw new Error("<ListboxOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<ListboxOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<ListboxOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ListboxOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListboxOptions_default = ListboxOptions;

// node_modules/@rgossiaux/svelte-headlessui/components/listbox/ListboxOption.svelte
var get_default_slot_spread_changes12 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes13 = (dirty) => ({});
var get_default_slot_context13 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context13
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        262148)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            get_default_slot_spread_changes12(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: '(100:0) <Render   {...$$restProps}   {...propsWeControl}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"ListboxOption\\"}   on:click={handleClick}   on:focus={handleFocus}   on:pointermove={handleMove}   on:mousemove={handleMove}   on:pointerleave={handleLeave}   on:mouseleave={handleLeave} >',
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[11],
    /*propsWeControl*/
    ctx[3],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[4]
      ]
    },
    { name: "ListboxOption" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  render.$on(
    "click",
    /*handleClick*/
    ctx[7]
  );
  render.$on(
    "focus",
    /*handleFocus*/
    ctx[8]
  );
  render.$on(
    "pointermove",
    /*handleMove*/
    ctx[9]
  );
  render.$on(
    "mousemove",
    /*handleMove*/
    ctx[9]
  );
  render.$on(
    "pointerleave",
    /*handleLeave*/
    ctx[10]
  );
  render.$on(
    "mouseleave",
    /*handleLeave*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      2079 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx2[11]
        ),
        dirty & /*propsWeControl*/
        8 && get_spread_object(
          /*propsWeControl*/
          ctx2[3]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        18 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[4]
          ]
        },
        render_spread_levels[5]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      262148) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let active;
  let selected;
  let dataRef;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $buttonRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListboxOption", slots, ["default"]);
  let { as = "li" } = $$props;
  let { use = [] } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useListboxContext("ListboxOption");
  validate_store(api, "api");
  component_subscribe($$self, api, (value2) => $$invalidate(16, $api = value2));
  let id2 = `headlessui-listbox-option-${useId()}`;
  let buttonRef = $api.buttonRef;
  validate_store(buttonRef, "buttonRef");
  component_subscribe($$self, buttonRef, (value2) => $$invalidate(23, $buttonRef = value2));
  onMount(() => {
    var _a, _b;
    let textValue = (_b = (_a = document.getElementById(id2)) == null ? void 0 : _a.textContent) == null ? void 0 : _b.toLowerCase().trim();
    if (textValue !== void 0)
      dataRef.textValue = textValue;
  });
  onMount(() => $api.registerOption(id2, dataRef));
  onDestroy(() => $api.unregisterOption(id2));
  let oldState = $api.listboxState;
  let oldSelected = selected;
  let oldActive = active;
  async function updateFocus(newState, newSelected, newActive) {
    var _a, _b;
    await tick();
    if (newState !== oldState || newSelected !== oldSelected) {
      if (newState === ListboxStates.Open && newSelected) {
        $api.goToOption(Focus2.Specific, id2);
      }
    }
    if (newState !== oldState || newActive !== oldActive) {
      if (newState === ListboxStates.Open && newActive) {
        (_b = (_a = document.getElementById(id2)) == null ? void 0 : _a.scrollIntoView) == null ? void 0 : _b.call(_a, { block: "nearest" });
      }
    }
    oldState = newState;
    oldSelected = newSelected;
    oldActive = newActive;
  }
  async function handleClick2(e) {
    let event = e;
    if (disabled)
      return event.preventDefault();
    $api.select(value);
    $api.closeListbox();
    await tick();
    $buttonRef == null ? void 0 : $buttonRef.focus({ preventScroll: true });
  }
  function handleFocus() {
    if (disabled)
      return $api.goToOption(Focus2.Nothing);
    $api.goToOption(Focus2.Specific, id2);
  }
  function handleMove() {
    if (disabled)
      return;
    if (active)
      return;
    $api.goToOption(Focus2.Specific, id2);
  }
  function handleLeave() {
    if (disabled)
      return;
    if (!active)
      return;
    $api.goToOption(Focus2.Nothing);
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ListboxOption> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(12, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    tick,
    ListboxStates,
    useListboxContext,
    useId,
    Focus: Focus2,
    Render: Render_default,
    forwardEventsBuilder,
    get_current_component,
    as,
    use,
    value,
    disabled,
    forwardEvents,
    api,
    id: id2,
    buttonRef,
    oldState,
    oldSelected,
    oldActive,
    updateFocus,
    handleClick: handleClick2,
    handleFocus,
    handleMove,
    handleLeave,
    selected,
    active,
    slotProps,
    propsWeControl,
    dataRef,
    $api,
    $buttonRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(12, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("api" in $$props)
      $$invalidate(5, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(24, id2 = $$new_props.id);
    if ("buttonRef" in $$props)
      $$invalidate(6, buttonRef = $$new_props.buttonRef);
    if ("oldState" in $$props)
      oldState = $$new_props.oldState;
    if ("oldSelected" in $$props)
      oldSelected = $$new_props.oldSelected;
    if ("oldActive" in $$props)
      oldActive = $$new_props.oldActive;
    if ("selected" in $$props)
      $$invalidate(14, selected = $$new_props.selected);
    if ("active" in $$props)
      $$invalidate(15, active = $$new_props.active);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
    if ("dataRef" in $$props)
      dataRef = $$new_props.dataRef;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    65536) {
      $:
        $$invalidate(15, active = $api.activeOptionIndex !== null ? $api.options[$api.activeOptionIndex].id === id2 : false);
    }
    if ($$self.$$.dirty & /*$api, value*/
    69632) {
      $:
        $$invalidate(14, selected = $api.value === value);
    }
    if ($$self.$$.dirty & /*disabled, value*/
    12288) {
      $:
        dataRef = { disabled, value, textValue: "" };
    }
    if ($$self.$$.dirty & /*$api, selected, active*/
    114688) {
      $:
        updateFocus($api.listboxState, selected, active);
    }
    if ($$self.$$.dirty & /*disabled, selected*/
    24576) {
      $:
        $$invalidate(3, propsWeControl = {
          id: id2,
          role: "option",
          tabIndex: disabled === true ? void 0 : -1,
          "aria-disabled": disabled === true ? true : void 0,
          "aria-selected": selected === true ? selected : void 0
        });
    }
    if ($$self.$$.dirty & /*active, selected, disabled*/
    57344) {
      $:
        $$invalidate(2, slotProps = { active, selected, disabled });
    }
  };
  return [
    as,
    use,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    buttonRef,
    handleClick2,
    handleFocus,
    handleMove,
    handleLeave,
    $$restProps,
    value,
    disabled,
    selected,
    active,
    $api,
    slots,
    $$scope
  ];
}
var ListboxOption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { as: 0, use: 1, value: 12, disabled: 13 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListboxOption",
      options,
      id: create_fragment19.name
    });
  }
  get as() {
    throw new Error("<ListboxOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<ListboxOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<ListboxOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ListboxOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ListboxOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ListboxOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListboxOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListboxOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListboxOption_default = ListboxOption;

// node_modules/@rgossiaux/svelte-headlessui/components/menu/Menu.svelte
var { Error: Error_16 } = globals;
var get_default_slot_spread_changes13 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes14 = (dirty) => ({});
var get_default_slot_context14 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context14
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        32772)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            get_default_slot_spread_changes13(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes14
            ),
            get_default_slot_context14
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: '(149:0) <Render   {...$$restProps}   use={[...use, forwardEvents]}   {as}   {slotProps}   name={\\"Menu\\"} >',
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let render;
  let current;
  let mounted;
  let dispose;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[9],
    {
      use: [
        .../*use*/
        ctx[0],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { as: (
      /*as*/
      ctx[1]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    { name: "Menu" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "mousedown",
          /*handleWindowMousedown*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, use, forwardEvents, as, slotProps*/
      527 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx2[9]
        ),
        dirty & /*use, forwardEvents*/
        9 && {
          use: [
            .../*use*/
            ctx2[0],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        dirty & /*as*/
        2 && { as: (
          /*as*/
          ctx2[1]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      32772) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var MenuStates;
(function(MenuStates2) {
  MenuStates2[MenuStates2["Open"] = 0] = "Open";
  MenuStates2[MenuStates2["Closed"] = 1] = "Closed";
})(MenuStates || (MenuStates = {}));
var MENU_CONTEXT_NAME = "headlessui-menu-context";
function useMenuContext(componentName) {
  let context = getContext(MENU_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${componentName} /> is missing a parent <Menu /> component.`);
  }
  return context;
}
function instance20($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["use", "as"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $openClosedState;
  let $buttonStore;
  let $api;
  let $itemsStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["default"]);
  let { use = [] } = $$props;
  let { as = "div" } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let menuState = MenuStates.Closed;
  let buttonStore = writable(null);
  validate_store(buttonStore, "buttonStore");
  component_subscribe($$self, buttonStore, (value) => $$invalidate(17, $buttonStore = value));
  let itemsStore = writable(null);
  validate_store(itemsStore, "itemsStore");
  component_subscribe($$self, itemsStore, (value) => $$invalidate(19, $itemsStore = value));
  let items = [];
  let searchQuery = "";
  let activeItemIndex = null;
  let api = writable({
    menuState,
    buttonStore,
    itemsStore,
    items,
    searchQuery,
    activeItemIndex,
    closeMenu: () => {
      $$invalidate(10, menuState = MenuStates.Closed);
      $$invalidate(13, activeItemIndex = null);
    },
    openMenu: () => $$invalidate(10, menuState = MenuStates.Open),
    goToItem(focus, id2) {
      let nextActiveItemIndex = calculateActiveIndex(
        focus === Focus2.Specific ? { focus: Focus2.Specific, id: id2 } : { focus },
        {
          resolveItems: () => items,
          resolveActiveIndex: () => activeItemIndex,
          resolveId: (item) => item.id,
          resolveDisabled: (item) => item.data.disabled
        }
      );
      if (searchQuery === "" && activeItemIndex === nextActiveItemIndex)
        return;
      $$invalidate(12, searchQuery = "");
      $$invalidate(13, activeItemIndex = nextActiveItemIndex);
    },
    search(value) {
      $$invalidate(12, searchQuery += value.toLowerCase());
      let reorderedItems = activeItemIndex !== null ? items.slice(activeItemIndex + 1).concat(items.slice(0, activeItemIndex + 1)) : items;
      let matchingItem = reorderedItems.find((item) => item.data.textValue.startsWith(searchQuery) && !item.data.disabled);
      let matchIdx = matchingItem ? items.indexOf(matchingItem) : -1;
      if (matchIdx === -1 || matchIdx === activeItemIndex)
        return;
      $$invalidate(13, activeItemIndex = matchIdx);
    },
    clearSearch() {
      $$invalidate(12, searchQuery = "");
    },
    registerItem(id2, data) {
      if (!$itemsStore) {
        $$invalidate(11, items = [...items, { id: id2, data }]);
        return;
      }
      let currentActiveItem = activeItemIndex !== null ? items[activeItemIndex] : null;
      let orderMap = Array.from($itemsStore.querySelectorAll('[id^="headlessui-menu-item-"]')).reduce((lookup, element2, index) => Object.assign(lookup, { [element2.id]: index }), {});
      let nextItems = [...items, { id: id2, data }];
      nextItems.sort((a, z) => orderMap[a.id] - orderMap[z.id]);
      $$invalidate(11, items = nextItems);
      $$invalidate(13, activeItemIndex = (() => {
        if (currentActiveItem === null)
          return null;
        return items.indexOf(currentActiveItem);
      })());
    },
    unregisterItem(id2) {
      let nextItems = items.slice();
      let currentActiveItem = activeItemIndex !== null ? nextItems[activeItemIndex] : null;
      let idx = nextItems.findIndex((a) => a.id === id2);
      if (idx !== -1)
        nextItems.splice(idx, 1);
      $$invalidate(11, items = nextItems);
      $$invalidate(13, activeItemIndex = (() => {
        if (idx === activeItemIndex)
          return null;
        if (currentActiveItem === null)
          return null;
        return nextItems.indexOf(currentActiveItem);
      })());
    }
  });
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(18, $api = value));
  setContext(MENU_CONTEXT_NAME, api);
  function handleWindowMousedown(event) {
    let target = event.target;
    let active = document.activeElement;
    if (menuState !== MenuStates.Open)
      return;
    if ($buttonStore == null ? void 0 : $buttonStore.contains(target))
      return;
    if (!($itemsStore == null ? void 0 : $itemsStore.contains(target)))
      $api.closeMenu();
    if (active !== document.body && (active == null ? void 0 : active.contains(target)))
      return;
    if (!event.defaultPrevented)
      $buttonStore == null ? void 0 : $buttonStore.focus({ preventScroll: true });
  }
  let openClosedState = writable(State.Closed);
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(16, $openClosedState = value));
  useOpenClosedProvider(openClosedState);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("as" in $$new_props)
      $$invalidate(1, as = $$new_props.as);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Focus: Focus2,
    calculateActiveIndex,
    getContext,
    setContext,
    writable,
    State,
    useOpenClosedProvider,
    match,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    MenuStates,
    MENU_CONTEXT_NAME,
    useMenuContext,
    use,
    as,
    forwardEvents,
    menuState,
    buttonStore,
    itemsStore,
    items,
    searchQuery,
    activeItemIndex,
    api,
    handleWindowMousedown,
    openClosedState,
    slotProps,
    $openClosedState,
    $buttonStore,
    $api,
    $itemsStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("as" in $$props)
      $$invalidate(1, as = $$new_props.as);
    if ("menuState" in $$props)
      $$invalidate(10, menuState = $$new_props.menuState);
    if ("buttonStore" in $$props)
      $$invalidate(4, buttonStore = $$new_props.buttonStore);
    if ("itemsStore" in $$props)
      $$invalidate(5, itemsStore = $$new_props.itemsStore);
    if ("items" in $$props)
      $$invalidate(11, items = $$new_props.items);
    if ("searchQuery" in $$props)
      $$invalidate(12, searchQuery = $$new_props.searchQuery);
    if ("activeItemIndex" in $$props)
      $$invalidate(13, activeItemIndex = $$new_props.activeItemIndex);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("openClosedState" in $$props)
      $$invalidate(8, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*menuState, items, searchQuery, activeItemIndex*/
    15360) {
      $:
        api.update((obj) => {
          return {
            ...obj,
            menuState,
            buttonStore,
            itemsStore,
            items,
            searchQuery,
            activeItemIndex
          };
        });
    }
    if ($$self.$$.dirty & /*menuState*/
    1024) {
      $:
        set_store_value(
          openClosedState,
          $openClosedState = match(menuState, {
            [MenuStates.Open]: State.Open,
            [MenuStates.Closed]: State.Closed
          }),
          $openClosedState
        );
    }
    if ($$self.$$.dirty & /*menuState*/
    1024) {
      $:
        $$invalidate(2, slotProps = { open: menuState === MenuStates.Open });
    }
  };
  return [
    use,
    as,
    slotProps,
    forwardEvents,
    buttonStore,
    itemsStore,
    api,
    handleWindowMousedown,
    openClosedState,
    $$restProps,
    menuState,
    items,
    searchQuery,
    activeItemIndex,
    slots,
    $$scope
  ];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { use: 0, as: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment20.name
    });
  }
  get use() {
    throw new Error_16("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_16("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error_16("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_16("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/@rgossiaux/svelte-headlessui/components/menu/MenuButton.svelte
var get_default_slot_spread_changes14 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes15 = (dirty) => ({});
var get_default_slot_context15 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context15
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        262152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            get_default_slot_spread_changes14(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes15
            ),
            get_default_slot_context15
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: '(88:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"MenuButton\\"}   bind:el={$buttonStore}   on:click={handleClick}   on:keydown={handleKeyDown}   on:keyup={handleKeyUp} >',
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[12],
      .../*propsWeControl*/
      ctx[4]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[7]
      ]
    },
    { name: "MenuButton" }
  ];
  function render_el_binding(value) {
    ctx[17](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$buttonStore*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*$buttonStore*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[11]
  );
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[9]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      4251 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        4112 && {
          .../*$$restProps*/
          ctx2[12],
          .../*propsWeControl*/
          ctx2[4]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*use, forwardEvents*/
        130 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[7]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      262152) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$buttonStore*/
      4) {
        updating_el = true;
        render_changes.el = /*$buttonStore*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let buttonStore;
  let itemsStore;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $itemsStore, $$unsubscribe_itemsStore = noop, $$subscribe_itemsStore = () => ($$unsubscribe_itemsStore(), $$unsubscribe_itemsStore = subscribe(itemsStore, ($$value) => $$invalidate(15, $itemsStore = $$value)), itemsStore);
  let $buttonStore, $$unsubscribe_buttonStore = noop, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(2, $buttonStore = $$value)), buttonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_itemsStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuButton", slots, ["default"]);
  let { as = "button" } = $$props;
  let { use = [] } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const api = useMenuContext("MenuButton");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(14, $api = value));
  const id2 = `headlessui-menu-button-${useId()}`;
  async function handleKeyDown(e) {
    let event = e;
    switch (event.key) {
      case Keys.Space:
      case Keys.Enter:
      case Keys.ArrowDown:
        event.preventDefault();
        event.stopPropagation();
        $api.openMenu();
        await tick();
        $itemsStore == null ? void 0 : $itemsStore.focus({ preventScroll: true });
        $api.goToItem(Focus2.First);
        break;
      case Keys.ArrowUp:
        event.preventDefault();
        event.stopPropagation();
        $api.openMenu();
        await tick();
        $itemsStore == null ? void 0 : $itemsStore.focus({ preventScroll: true });
        $api.goToItem(Focus2.Last);
        break;
    }
  }
  function handleKeyUp(e) {
    let event = e;
    switch (event.key) {
      case Keys.Space:
        event.preventDefault();
        break;
    }
  }
  async function handleClick2(e) {
    let event = e;
    if (disabled)
      return;
    if ($api.menuState === MenuStates.Open) {
      $api.closeMenu();
      await tick();
      $buttonStore == null ? void 0 : $buttonStore.focus({ preventScroll: true });
    } else {
      event.preventDefault();
      event.stopPropagation();
      $api.openMenu();
      await tick();
      $itemsStore == null ? void 0 : $itemsStore.focus({ preventScroll: true });
    }
  }
  function render_el_binding(value) {
    $buttonStore = value;
    buttonStore.set($buttonStore);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$new_props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useMenuContext,
    MenuStates,
    useId,
    Keys,
    Focus: Focus2,
    tick,
    Render: Render_default,
    forwardEventsBuilder,
    get_current_component,
    resolveButtonType,
    as,
    use,
    disabled,
    forwardEvents,
    api,
    id: id2,
    handleKeyDown,
    handleKeyUp,
    handleClick: handleClick2,
    slotProps,
    propsWeControl,
    itemsStore,
    buttonStore,
    $api,
    $itemsStore,
    $buttonStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
    if ("itemsStore" in $$props)
      $$subscribe_itemsStore($$invalidate(5, itemsStore = $$new_props.itemsStore));
    if ("buttonStore" in $$props)
      $$subscribe_buttonStore($$invalidate(6, buttonStore = $$new_props.buttonStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$subscribe_buttonStore($$invalidate(6, buttonStore = $api.buttonStore));
    }
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$subscribe_itemsStore($$invalidate(5, itemsStore = $api.itemsStore));
    }
    $:
      $$invalidate(4, propsWeControl = {
        id: id2,
        type: resolveButtonType({ type: $$props.type, as }, $buttonStore),
        disabled: disabled ? true : void 0,
        "aria-haspopup": true,
        "aria-controls": $itemsStore == null ? void 0 : $itemsStore.id,
        "aria-expanded": disabled ? void 0 : $api.menuState === MenuStates.Open
      });
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$invalidate(3, slotProps = { open: $api.menuState === MenuStates.Open });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    $buttonStore,
    slotProps,
    propsWeControl,
    itemsStore,
    buttonStore,
    forwardEvents,
    api,
    handleKeyDown,
    handleKeyUp,
    handleClick2,
    $$restProps,
    disabled,
    $api,
    $itemsStore,
    slots,
    render_el_binding,
    $$scope
  ];
}
var MenuButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { as: 0, use: 1, disabled: 13 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuButton",
      options,
      id: create_fragment21.name
    });
  }
  get as() {
    throw new Error("<MenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<MenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<MenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenuButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenuButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuButton_default = MenuButton;

// node_modules/@rgossiaux/svelte-headlessui/hooks/use-tree-walker.js
function treeWalker({ container, accept, walk, enabled }) {
  let root = container;
  if (!root)
    return;
  if (enabled !== void 0 && !enabled)
    return;
  let acceptNode = Object.assign((node) => accept(node), {
    acceptNode: accept
  });
  let walker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_ELEMENT,
    acceptNode,
    // @ts-ignore-error Typescript bug thinks this can only have 3 args
    false
  );
  while (walker.nextNode())
    walk(walker.currentNode);
}

// node_modules/@rgossiaux/svelte-headlessui/components/menu/MenuItems.svelte
var get_default_slot_spread_changes15 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes16 = (dirty) => ({});
var get_default_slot_context16 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context16
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524296)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes15(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes16
            ),
            get_default_slot_context16
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: '(130:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   use={[...use, forwardEvents]}   bind:el={$itemsStore}   name={\\"MenuItems\\"}   on:keydown={handleKeyDown}   on:keyup={handleKeyUp}   {visible}   features={Features.RenderStrategy | Features.Static} >',
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[13],
      .../*propsWeControl*/
      ctx[4]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[8]
      ]
    },
    { name: "MenuItems" },
    { visible: (
      /*visible*/
      ctx[5]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  function render_el_binding(value) {
    ctx[18](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$itemsStore*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*$itemsStore*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[11]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents, visible, Features*/
      8507 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        8208 && {
          .../*$$restProps*/
          ctx2[13],
          .../*propsWeControl*/
          ctx2[4]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*use, forwardEvents*/
        258 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[8]
          ]
        },
        render_spread_levels[4],
        dirty & /*visible*/
        32 && { visible: (
          /*visible*/
          ctx2[5]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524296) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$itemsStore*/
      4) {
        updating_el = true;
        render_changes.el = /*$itemsStore*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let buttonStore;
  let itemsStore;
  let visible;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $buttonStore, $$unsubscribe_buttonStore = noop, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(15, $buttonStore = $$value)), buttonStore);
  let $itemsStore, $$unsubscribe_itemsStore = noop, $$subscribe_itemsStore = () => ($$unsubscribe_itemsStore(), $$unsubscribe_itemsStore = subscribe(itemsStore, ($$value) => $$invalidate(2, $itemsStore = $$value)), itemsStore);
  let $openClosedState;
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_itemsStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuItems", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const api = useMenuContext("MenuItems");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(14, $api = value));
  const id2 = `headlessui-menu-items-${useId()}`;
  let searchDebounce = null;
  let openClosedState = useOpenClosed();
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(16, $openClosedState = value));
  async function handleKeyDown(e) {
    var _a;
    if (searchDebounce)
      clearTimeout(searchDebounce);
    let event = e;
    switch (event.key) {
      case Keys.Space:
        if ($api.searchQuery !== "") {
          event.preventDefault();
          event.stopPropagation();
          return $api.search(event.key);
        }
      case Keys.Enter:
        event.preventDefault();
        event.stopPropagation();
        if ($api.activeItemIndex !== null) {
          let { id: id3 } = $api.items[$api.activeItemIndex];
          (_a = document.getElementById(id3)) == null ? void 0 : _a.click();
        }
        $api.closeMenu();
        await tick();
        $buttonStore == null ? void 0 : $buttonStore.focus({ preventScroll: true });
        break;
      case Keys.ArrowDown:
        event.preventDefault();
        event.stopPropagation();
        return $api.goToItem(Focus2.Next);
      case Keys.ArrowUp:
        event.preventDefault();
        event.stopPropagation();
        return $api.goToItem(Focus2.Previous);
      case Keys.Home:
      case Keys.PageUp:
        event.preventDefault();
        event.stopPropagation();
        return $api.goToItem(Focus2.First);
      case Keys.End:
      case Keys.PageDown:
        event.preventDefault();
        event.stopPropagation();
        return $api.goToItem(Focus2.Last);
      case Keys.Escape:
        event.preventDefault();
        event.stopPropagation();
        $api.closeMenu();
        await tick();
        $buttonStore == null ? void 0 : $buttonStore.focus({ preventScroll: true });
        break;
      case Keys.Tab:
        event.preventDefault();
        event.stopPropagation();
        break;
      default:
        if (event.key.length === 1) {
          $api.search(event.key);
          searchDebounce = setTimeout(() => $api.clearSearch(), 350);
        }
        break;
    }
  }
  function handleKeyUp(e) {
    let event = e;
    switch (event.key) {
      case Keys.Space:
        event.preventDefault();
        break;
    }
  }
  function render_el_binding(value) {
    $itemsStore = value;
    itemsStore.set($itemsStore);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useMenuContext,
    MenuStates,
    useId,
    Keys,
    Focus: Focus2,
    treeWalker,
    State,
    useOpenClosed,
    tick,
    Render: Render_default,
    forwardEventsBuilder,
    get_current_component,
    Features,
    as,
    use,
    forwardEvents,
    api,
    id: id2,
    searchDebounce,
    openClosedState,
    handleKeyDown,
    handleKeyUp,
    slotProps,
    propsWeControl,
    visible,
    itemsStore,
    buttonStore,
    $api,
    $buttonStore,
    $itemsStore,
    $openClosedState
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("searchDebounce" in $$props)
      searchDebounce = $$new_props.searchDebounce;
    if ("openClosedState" in $$props)
      $$invalidate(10, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
    if ("visible" in $$props)
      $$invalidate(5, visible = $$new_props.visible);
    if ("itemsStore" in $$props)
      $$subscribe_itemsStore($$invalidate(6, itemsStore = $$new_props.itemsStore));
    if ("buttonStore" in $$props)
      $$subscribe_buttonStore($$invalidate(7, buttonStore = $$new_props.buttonStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$subscribe_buttonStore($$invalidate(7, buttonStore = $api.buttonStore));
    }
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$subscribe_itemsStore($$invalidate(6, itemsStore = $api.itemsStore));
    }
    if ($$self.$$.dirty & /*$openClosedState, $api*/
    81920) {
      $:
        $$invalidate(5, visible = openClosedState !== void 0 ? $openClosedState === State.Open : $api.menuState === MenuStates.Open);
    }
    if ($$self.$$.dirty & /*$itemsStore, $api*/
    16388) {
      $:
        treeWalker({
          container: $itemsStore,
          enabled: $api.menuState === MenuStates.Open,
          accept(node) {
            if (node.getAttribute("role") === "menuitem")
              return NodeFilter.FILTER_REJECT;
            if (node.hasAttribute("role"))
              return NodeFilter.FILTER_SKIP;
            return NodeFilter.FILTER_ACCEPT;
          },
          walk(node) {
            node.setAttribute("role", "none");
          }
        });
    }
    if ($$self.$$.dirty & /*$api, $buttonStore*/
    49152) {
      $:
        $$invalidate(4, propsWeControl = {
          "aria-activedescendant": $api.activeItemIndex === null ? void 0 : (_a = $api.items[$api.activeItemIndex]) == null ? void 0 : _a.id,
          "aria-labelledby": $buttonStore == null ? void 0 : $buttonStore.id,
          id: id2,
          role: "menu",
          tabIndex: 0
        });
    }
    if ($$self.$$.dirty & /*$api*/
    16384) {
      $:
        $$invalidate(3, slotProps = { open: $api.menuState === MenuStates.Open });
    }
  };
  return [
    as,
    use,
    $itemsStore,
    slotProps,
    propsWeControl,
    visible,
    itemsStore,
    buttonStore,
    forwardEvents,
    api,
    openClosedState,
    handleKeyDown,
    handleKeyUp,
    $$restProps,
    $api,
    $buttonStore,
    $openClosedState,
    slots,
    render_el_binding,
    $$scope
  ];
}
var MenuItems = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuItems",
      options,
      id: create_fragment22.name
    });
  }
  get as() {
    throw new Error("<MenuItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<MenuItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<MenuItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MenuItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuItems_default = MenuItems;

// node_modules/@rgossiaux/svelte-headlessui/components/menu/MenuItem.svelte
var get_default_slot_spread_changes16 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes17 = (dirty) => ({});
var get_default_slot_context17 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context17
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524296)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes16(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes17
            ),
            get_default_slot_context17
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: '(82:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   use={[...use, forwardEvents]}   {as}   {slotProps}   name={\\"MenuItem\\"}   bind:el={elementRef}   on:click={handleClick}   on:focus={handleFocus}   on:pointermove={handleMove}   on:mousemove={handleMove}   on:pointerleave={handleLeave}   on:mouseleave={handleLeave} >',
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[12],
      .../*propsWeControl*/
      ctx[4]
    },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    { name: "MenuItem" }
  ];
  function render_el_binding(value) {
    ctx[18](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*elementRef*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*elementRef*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[8]
  );
  render.$on(
    "focus",
    /*handleFocus*/
    ctx[9]
  );
  render.$on(
    "pointermove",
    /*handleMove*/
    ctx[10]
  );
  render.$on(
    "mousemove",
    /*handleMove*/
    ctx[10]
  );
  render.$on(
    "pointerleave",
    /*handleLeave*/
    ctx[11]
  );
  render.$on(
    "mouseleave",
    /*handleLeave*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, use, forwardEvents, as, slotProps*/
      4187 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        4112 && {
          .../*$$restProps*/
          ctx2[12],
          .../*propsWeControl*/
          ctx2[4]
        },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524296) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*elementRef*/
      4) {
        updating_el = true;
        render_changes.el = /*elementRef*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let active;
  let buttonStore;
  let textValue;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $buttonStore, $$unsubscribe_buttonStore = noop, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(21, $buttonStore = $$value)), buttonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuItem", slots, ["default"]);
  let { as = "a" } = $$props;
  let { use = [] } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component(), [
    {
      name: "click",
      shouldExclude: () => disabled
    }
  ]);
  const api = useMenuContext("MenuItem");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(16, $api = value));
  const id2 = `headlessui-menu-item-${useId()}`;
  let elementRef;
  let data = { disabled, textValue };
  onMount(async () => {
    $api.registerItem(id2, data);
  });
  onDestroy(() => {
    $api.unregisterItem(id2);
  });
  afterUpdate(async () => {
    var _a;
    if ($api.menuState !== MenuStates.Open)
      return;
    if (!active)
      return;
    await tick();
    (_a = elementRef == null ? void 0 : elementRef.scrollIntoView) == null ? void 0 : _a.call(elementRef, { block: "nearest" });
  });
  async function handleClick2(event) {
    if (disabled)
      return event.preventDefault();
    $api.closeMenu();
    $buttonStore == null ? void 0 : $buttonStore.focus({ preventScroll: true });
  }
  function handleFocus() {
    if (disabled)
      return $api.goToItem(Focus2.Nothing);
    $api.goToItem(Focus2.Specific, id2);
  }
  function handleMove() {
    if (disabled)
      return;
    if (active)
      return;
    $api.goToItem(Focus2.Specific, id2);
  }
  function handleLeave() {
    if (disabled)
      return;
    if (!active)
      return;
    $api.goToItem(Focus2.Nothing);
  }
  function render_el_binding(value) {
    elementRef = value;
    $$invalidate(2, elementRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$new_props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useMenuContext,
    MenuStates,
    useId,
    Focus: Focus2,
    afterUpdate,
    onDestroy,
    onMount,
    tick,
    Render: Render_default,
    forwardEventsBuilder,
    get_current_component,
    as,
    use,
    disabled,
    forwardEvents,
    api,
    id: id2,
    elementRef,
    data,
    handleClick: handleClick2,
    handleFocus,
    handleMove,
    handleLeave,
    active,
    slotProps,
    propsWeControl,
    textValue,
    buttonStore,
    $api,
    $buttonStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("elementRef" in $$props)
      $$invalidate(2, elementRef = $$new_props.elementRef);
    if ("data" in $$props)
      data = $$new_props.data;
    if ("active" in $$props)
      $$invalidate(14, active = $$new_props.active);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
    if ("textValue" in $$props)
      $$invalidate(15, textValue = $$new_props.textValue);
    if ("buttonStore" in $$props)
      $$subscribe_buttonStore($$invalidate(5, buttonStore = $$new_props.buttonStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*$api*/
    65536) {
      $:
        $$invalidate(14, active = $api.activeItemIndex !== null ? $api.items[$api.activeItemIndex].id === id2 : false);
    }
    if ($$self.$$.dirty & /*$api*/
    65536) {
      $:
        $$subscribe_buttonStore($$invalidate(5, buttonStore = $api.buttonStore));
    }
    if ($$self.$$.dirty & /*elementRef*/
    4) {
      $:
        $$invalidate(15, textValue = ((_a = elementRef == null ? void 0 : elementRef.textContent) == null ? void 0 : _a.toLowerCase().trim()) || "");
    }
    if ($$self.$$.dirty & /*disabled*/
    8192) {
      $:
        data.disabled = disabled;
    }
    if ($$self.$$.dirty & /*textValue*/
    32768) {
      $:
        data.textValue = textValue;
    }
    if ($$self.$$.dirty & /*disabled*/
    8192) {
      $:
        $$invalidate(4, propsWeControl = {
          id: id2,
          role: "menuitem",
          tabIndex: disabled === true ? void 0 : -1,
          "aria-disabled": disabled === true ? true : void 0
        });
    }
    if ($$self.$$.dirty & /*active, disabled*/
    24576) {
      $:
        $$invalidate(3, slotProps = { active, disabled });
    }
  };
  return [
    as,
    use,
    elementRef,
    slotProps,
    propsWeControl,
    buttonStore,
    forwardEvents,
    api,
    handleClick2,
    handleFocus,
    handleMove,
    handleLeave,
    $$restProps,
    disabled,
    active,
    textValue,
    $api,
    slots,
    render_el_binding,
    $$scope
  ];
}
var MenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { as: 0, use: 1, disabled: 13 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuItem",
      options,
      id: create_fragment23.name
    });
  }
  get as() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuItem_default = MenuItem;

// node_modules/@rgossiaux/svelte-headlessui/components/popover/PopoverGroup.svelte
var get_default_slot_spread_changes17 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes18 = (dirty) => ({});
var get_default_slot_context18 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context18
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        264)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            get_default_slot_spread_changes17(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes18
            ),
            get_default_slot_context18
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: '(52:0) <Render   {...$$restProps}   {as}   use={[...use, forwardEvents]}   {slotProps}   name={\\"PopoverGroup\\"}   bind:el={groupRef} >',
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[5],
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[4]
      ]
    },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    { name: "PopoverGroup" }
  ];
  function render_el_binding(value) {
    ctx[7](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*groupRef*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*groupRef*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, use, forwardEvents, slotProps*/
      59 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        18 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[4]
          ]
        },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      264) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*groupRef*/
      4) {
        updating_el = true;
        render_changes.el = /*groupRef*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var POPOVER_GROUP_CONTEXT_NAME = "headlessui-popover-group-context";
function usePopoverGroupContext() {
  return getContext(POPOVER_GROUP_CONTEXT_NAME);
}
function instance24($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverGroup", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let groupRef;
  let popovers = [];
  function unregisterPopover(registerBag) {
    popovers = popovers.filter((bag) => bag != registerBag);
  }
  function registerPopover(registerBag) {
    popovers = [...popovers, registerBag];
    return () => {
      unregisterPopover(registerBag);
    };
  }
  function isFocusWithinPopoverGroup() {
    let element2 = document.activeElement;
    if (groupRef == null ? void 0 : groupRef.contains(element2))
      return true;
    return popovers.some((bag) => {
      var _a, _b;
      return ((_a = document.getElementById(bag.buttonId)) == null ? void 0 : _a.contains(element2)) || ((_b = document.getElementById(bag.panelId)) == null ? void 0 : _b.contains(element2));
    });
  }
  function closeOthers(buttonId) {
    for (let popover of popovers) {
      if (popover.buttonId !== buttonId)
        popover.close();
    }
  }
  setContext(POPOVER_GROUP_CONTEXT_NAME, {
    unregisterPopover,
    registerPopover,
    isFocusWithinPopoverGroup,
    closeOthers
  });
  function render_el_binding(value) {
    groupRef = value;
    $$invalidate(2, groupRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    POPOVER_GROUP_CONTEXT_NAME,
    usePopoverGroupContext,
    getContext,
    setContext,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    groupRef,
    popovers,
    unregisterPopover,
    registerPopover,
    isFocusWithinPopoverGroup,
    closeOthers,
    slotProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("groupRef" in $$props)
      $$invalidate(2, groupRef = $$new_props.groupRef);
    if ("popovers" in $$props)
      popovers = $$new_props.popovers;
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(3, slotProps = {});
  return [
    as,
    use,
    groupRef,
    slotProps,
    forwardEvents,
    $$restProps,
    slots,
    render_el_binding,
    $$scope
  ];
}
var PopoverGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverGroup",
      options,
      id: create_fragment24.name
    });
  }
  get as() {
    throw new Error("<PopoverGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<PopoverGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<PopoverGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<PopoverGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverGroup_default = PopoverGroup;

// node_modules/@rgossiaux/svelte-headlessui/components/popover/Popover.svelte
var { Error: Error_17, window: window_13 } = globals;
var get_default_slot_spread_changes18 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes19 = (dirty) => ({});
var get_default_slot_context19 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context19
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        16388)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            get_default_slot_spread_changes18(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes19
            ),
            get_default_slot_context19
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: '(131:0) <Render   {...$$restProps}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"Popover\\"} >',
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let render;
  let current;
  let mounted;
  let dispose;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[10],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { name: "Popover" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_13,
            "focus",
            /*handleFocus*/
            ctx[8],
            true,
            false,
            false,
            false
          ),
          listen_dev(
            window_13,
            "mousedown",
            /*handleMousedown*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, slotProps, use, forwardEvents*/
      1039 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx2[10]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      16388) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var PopoverStates;
(function(PopoverStates2) {
  PopoverStates2[PopoverStates2["Open"] = 0] = "Open";
  PopoverStates2[PopoverStates2["Closed"] = 1] = "Closed";
})(PopoverStates || (PopoverStates = {}));
var POPOVER_CONTEXT_NAME = "headlessui-popover-context";
function usePopoverContext(component) {
  let context = getContext(POPOVER_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${component} /> is missing a parent <Popover /> component.`);
  }
  return context;
}
function instance25($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $button;
  let $panel;
  let $openClosedState;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const buttonId = `headlessui-popover-button-${useId()}`;
  const panelId = `headlessui-popover-panel-${useId()}`;
  let popoverState = PopoverStates.Closed;
  let panel = writable(null);
  validate_store(panel, "panel");
  component_subscribe($$self, panel, (value) => $$invalidate(16, $panel = value));
  let button = writable(null);
  validate_store(button, "button");
  component_subscribe($$self, button, (value) => $$invalidate(15, $button = value));
  let api = writable({
    popoverState,
    buttonId,
    panelId,
    panel,
    button,
    togglePopover() {
      $$invalidate(11, popoverState = match(popoverState, {
        [PopoverStates.Open]: PopoverStates.Closed,
        [PopoverStates.Closed]: PopoverStates.Open
      }));
    },
    closePopover() {
      if (popoverState === PopoverStates.Closed)
        return;
      $$invalidate(11, popoverState = PopoverStates.Closed);
    },
    close(focusableElement) {
      $api.closePopover();
      let restoreElement = (() => {
        if (!focusableElement)
          return $button;
        if (focusableElement instanceof HTMLElement)
          return focusableElement;
        return $button;
      })();
      restoreElement == null ? void 0 : restoreElement.focus();
    }
  });
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(12, $api = value));
  setContext(POPOVER_CONTEXT_NAME, api);
  let openClosedState = writable(State.Closed);
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(17, $openClosedState = value));
  useOpenClosedProvider(openClosedState);
  const registerBag = {
    buttonId,
    panelId,
    close() {
      $api.closePopover();
    }
  };
  const groupContext = usePopoverGroupContext();
  const registerPopover = groupContext == null ? void 0 : groupContext.registerPopover;
  function isFocusWithinPopoverGroup() {
    return (groupContext == null ? void 0 : groupContext.isFocusWithinPopoverGroup()) ?? (($button == null ? void 0 : $button.contains(document.activeElement)) || ($panel == null ? void 0 : $panel.contains(document.activeElement)));
  }
  onMount(() => registerPopover == null ? void 0 : registerPopover(registerBag));
  function handleFocus(event) {
    if (event.target === window.document.body) {
      return;
    }
    if (popoverState !== PopoverStates.Open)
      return;
    if (isFocusWithinPopoverGroup())
      return;
    if (!button)
      return;
    if (!panel)
      return;
    $api.closePopover();
  }
  function handleMousedown(event) {
    let target = event.target;
    if (popoverState !== PopoverStates.Open)
      return;
    if ($button == null ? void 0 : $button.contains(target))
      return;
    if ($panel == null ? void 0 : $panel.contains(target))
      return;
    $api.closePopover();
    if (!isFocusableElement(target, FocusableMode.Loose)) {
      event.preventDefault();
      $button == null ? void 0 : $button.focus();
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PopoverStates,
    POPOVER_CONTEXT_NAME,
    usePopoverContext,
    match,
    useId,
    isFocusableElement,
    FocusableMode,
    State,
    useOpenClosedProvider,
    usePopoverGroupContext,
    getContext,
    setContext,
    onMount,
    writable,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    buttonId,
    panelId,
    popoverState,
    panel,
    button,
    api,
    openClosedState,
    registerBag,
    groupContext,
    registerPopover,
    isFocusWithinPopoverGroup,
    handleFocus,
    handleMousedown,
    slotProps,
    $api,
    $button,
    $panel,
    $openClosedState
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("popoverState" in $$props)
      $$invalidate(11, popoverState = $$new_props.popoverState);
    if ("panel" in $$props)
      $$invalidate(4, panel = $$new_props.panel);
    if ("button" in $$props)
      $$invalidate(5, button = $$new_props.button);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("openClosedState" in $$props)
      $$invalidate(7, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*popoverState*/
    2048) {
      $:
        set_store_value(
          openClosedState,
          $openClosedState = match(popoverState, {
            [PopoverStates.Open]: State.Open,
            [PopoverStates.Closed]: State.Closed
          }),
          $openClosedState
        );
    }
    if ($$self.$$.dirty & /*popoverState*/
    2048) {
      $:
        api.update((obj) => {
          return { ...obj, popoverState };
        });
    }
    if ($$self.$$.dirty & /*popoverState, $api*/
    6144) {
      $:
        $$invalidate(2, slotProps = {
          open: popoverState === PopoverStates.Open,
          close: $api.close
        });
    }
  };
  return [
    as,
    use,
    slotProps,
    forwardEvents,
    panel,
    button,
    api,
    openClosedState,
    handleFocus,
    handleMousedown,
    $$restProps,
    popoverState,
    $api,
    slots,
    $$scope
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment25.name
    });
  }
  get as() {
    throw new Error_17("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_17("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_17("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_17("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/@rgossiaux/svelte-headlessui/components/popover/PopoverOverlay.svelte
var get_default_slot_spread_changes19 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes20 = (dirty) => ({});
var get_default_slot_context20 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context20
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        8200)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            get_default_slot_spread_changes19(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes20
            ),
            get_default_slot_context20
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: '(30:0) <Render   {...$$restProps}   {...propsWeControl}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"PopoverOverlay\\"}   on:click={handleClick}   aria-hidden   {visible}   features={Features.RenderStrategy | Features.Static} >',
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[9],
    /*propsWeControl*/
    ctx[2],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[5]
      ]
    },
    { name: "PopoverOverlay" },
    { "aria-hidden": true },
    { visible: (
      /*visible*/
      ctx[4]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  render.$on(
    "click",
    /*handleClick*/
    ctx[8]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents, visible, Features*/
      575 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx2[9]
        ),
        dirty & /*propsWeControl*/
        4 && get_spread_object(
          /*propsWeControl*/
          ctx2[2]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*use, forwardEvents*/
        34 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[5]
          ]
        },
        render_spread_levels[5],
        render_spread_levels[6],
        dirty & /*visible*/
        16 && { visible: (
          /*visible*/
          ctx2[4]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      8200) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let visible;
  let slotProps;
  let propsWeControl;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $openClosedState;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverOverlay", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = usePopoverContext("PopoverOverlay");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(10, $api = value));
  let id2 = `headlessui-popover-overlay-${useId()}`;
  let openClosedState = useOpenClosed();
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(11, $openClosedState = value));
  function handleClick2() {
    $api.closePopover();
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    State,
    useOpenClosed,
    PopoverStates,
    usePopoverContext,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    useId,
    Features,
    as,
    use,
    forwardEvents,
    api,
    id: id2,
    openClosedState,
    handleClick: handleClick2,
    propsWeControl,
    slotProps,
    visible,
    $api,
    $openClosedState
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(14, id2 = $$new_props.id);
    if ("openClosedState" in $$props)
      $$invalidate(7, openClosedState = $$new_props.openClosedState);
    if ("propsWeControl" in $$props)
      $$invalidate(2, propsWeControl = $$new_props.propsWeControl);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("visible" in $$props)
      $$invalidate(4, visible = $$new_props.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$openClosedState, $api*/
    3072) {
      $:
        $$invalidate(4, visible = openClosedState !== void 0 ? $openClosedState === State.Open : $api.popoverState === PopoverStates.Open);
    }
    if ($$self.$$.dirty & /*$api*/
    1024) {
      $:
        $$invalidate(3, slotProps = {
          open: $api.popoverState === PopoverStates.Open
        });
    }
  };
  $:
    $$invalidate(2, propsWeControl = { id: id2 });
  return [
    as,
    use,
    propsWeControl,
    slotProps,
    visible,
    forwardEvents,
    api,
    openClosedState,
    handleClick2,
    $$restProps,
    $api,
    $openClosedState,
    slots,
    $$scope
  ];
}
var PopoverOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverOverlay",
      options,
      id: create_fragment26.name
    });
  }
  get as() {
    throw new Error("<PopoverOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<PopoverOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<PopoverOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<PopoverOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverOverlay_default = PopoverOverlay;

// node_modules/@rgossiaux/svelte-headlessui/components/popover/PopoverPanel.svelte
var { window: window_14 } = globals;
var get_default_slot_spread_changes20 = (dirty) => dirty & /*slotProps*/
16;
var get_default_slot_changes21 = (dirty) => ({});
var get_default_slot_context21 = (ctx) => ({ .../*slotProps*/
ctx[4] });
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context21
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes20(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes21
            ),
            get_default_slot_context21
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: '(123:0) <Render   {...$$restProps}   id={$api.panelId}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"PopoverPanel\\"}   bind:el={$panelStore}   on:keydown={handleKeydown}   {visible}   features={Features.RenderStrategy | Features.Static} >',
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let render;
  let updating_el;
  let current;
  let mounted;
  let dispose;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[14],
    { id: (
      /*$api*/
      ctx[2].panelId
    ) },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[4]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "PopoverPanel" },
    { visible: (
      /*visible*/
      ctx[5]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  function render_el_binding(value) {
    ctx[18](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$panelStore*/
    ctx[3] !== void 0
  ) {
    render_props.el = /*$panelStore*/
    ctx[3];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "keydown",
    /*handleKeydown*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_14,
            "keydown",
            /*handleWindowKeydown*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_14,
            "focus",
            /*handleFocus*/
            ctx[12],
            true,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, $api, as, slotProps, use, forwardEvents, visible, Features*/
      16503 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        16384 && get_spread_object(
          /*$$restProps*/
          ctx2[14]
        ),
        dirty & /*$api*/
        4 && { id: (
          /*$api*/
          ctx2[2].panelId
        ) },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        16 && { slotProps: (
          /*slotProps*/
          ctx2[4]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        render_spread_levels[5],
        dirty & /*visible*/
        32 && { visible: (
          /*visible*/
          ctx2[5]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524304) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$panelStore*/
      8) {
        updating_el = true;
        render_changes.el = /*$panelStore*/
        ctx2[3];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var POPOVER_PANEL_CONTEXT_NAME = "headlessui-popover-panel-context";
function usePopoverPanelContext() {
  return getContext(POPOVER_PANEL_CONTEXT_NAME);
}
function instance27($$self, $$props, $$invalidate) {
  let visible;
  let slotProps;
  const omit_props_names = ["as", "use", "focus"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $apiButton;
  let $panelStore;
  let $openClosedState;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverPanel", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { focus = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = usePopoverContext("PopoverPanel");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(2, $api = value));
  setContext(POPOVER_PANEL_CONTEXT_NAME, $api.panelId);
  let panelStore = $api.panel;
  validate_store(panelStore, "panelStore");
  component_subscribe($$self, panelStore, (value) => $$invalidate(3, $panelStore = value));
  let apiButton = $api.button;
  validate_store(apiButton, "apiButton");
  component_subscribe($$self, apiButton, (value) => $$invalidate(20, $apiButton = value));
  let openClosedState = useOpenClosed();
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(16, $openClosedState = value));
  function handleWindowKeydown(event) {
    if ($api.popoverState !== PopoverStates.Open)
      return;
    if (!$panelStore)
      return;
    if (event.key !== Keys.Tab)
      return;
    if (!document.activeElement)
      return;
    if (!($panelStore == null ? void 0 : $panelStore.contains(document.activeElement)))
      return;
    event.preventDefault();
    let result = focusIn($panelStore, event.shiftKey ? Focus.Previous : Focus.Next);
    if (result === FocusResult.Underflow) {
      return $apiButton == null ? void 0 : $apiButton.focus();
    } else if (result === FocusResult.Overflow) {
      if (!$apiButton)
        return;
      let elements = getFocusableElements();
      let buttonIdx = elements.indexOf($apiButton);
      let nextElements = elements.splice(buttonIdx + 1).filter(
        (element2) => !($panelStore == null ? void 0 : $panelStore.contains(element2))
      );
      if (focusIn(nextElements, Focus.First) === FocusResult.Error) {
        focusIn(document.body, Focus.First);
      }
    }
  }
  function handleFocus(event) {
    if (event.target === window.document.body) {
      return;
    }
    if (!focus)
      return;
    if ($api.popoverState !== PopoverStates.Open)
      return;
    if (!$panelStore)
      return;
    if ($panelStore.contains(document.activeElement))
      return;
    $api.closePopover();
  }
  function handleKeydown(e) {
    let event = e;
    switch (event.key) {
      case Keys.Escape:
        if ($api.popoverState !== PopoverStates.Open)
          return;
        if (!$panelStore)
          return;
        if (!$panelStore.contains(document.activeElement))
          return;
        event.preventDefault();
        event.stopPropagation();
        $api.closePopover();
        $apiButton == null ? void 0 : $apiButton.focus();
        break;
    }
  }
  function render_el_binding(value) {
    $panelStore = value;
    panelStore.set($panelStore);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("focus" in $$new_props)
      $$invalidate(15, focus = $$new_props.focus);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    POPOVER_PANEL_CONTEXT_NAME,
    usePopoverPanelContext,
    Keys,
    State,
    useOpenClosed,
    getFocusableElements,
    Focus,
    FocusResult,
    focusIn,
    getContext,
    setContext,
    PopoverStates,
    usePopoverContext,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    Features,
    as,
    use,
    focus,
    forwardEvents,
    api,
    panelStore,
    apiButton,
    openClosedState,
    handleWindowKeydown,
    handleFocus,
    handleKeydown,
    slotProps,
    visible,
    $api,
    $apiButton,
    $panelStore,
    $openClosedState
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("focus" in $$props)
      $$invalidate(15, focus = $$new_props.focus);
    if ("api" in $$props)
      $$invalidate(7, api = $$new_props.api);
    if ("panelStore" in $$props)
      $$invalidate(8, panelStore = $$new_props.panelStore);
    if ("apiButton" in $$props)
      $$invalidate(9, apiButton = $$new_props.apiButton);
    if ("openClosedState" in $$props)
      $$invalidate(10, openClosedState = $$new_props.openClosedState);
    if ("slotProps" in $$props)
      $$invalidate(4, slotProps = $$new_props.slotProps);
    if ("visible" in $$props)
      $$invalidate(5, visible = $$new_props.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$openClosedState, $api*/
    65540) {
      $:
        $$invalidate(5, visible = openClosedState !== void 0 ? $openClosedState === State.Open : $api.popoverState === PopoverStates.Open);
    }
    if ($$self.$$.dirty & /*focus, $api, $panelStore*/
    32780) {
      $:
        (() => {
          if (!focus)
            return;
          if ($api.popoverState !== PopoverStates.Open)
            return;
          if (!$panelStore)
            return;
          let activeElement = document.activeElement;
          if ($panelStore.contains(activeElement))
            return;
          focusIn($panelStore, Focus.First);
        })();
    }
    if ($$self.$$.dirty & /*$api*/
    4) {
      $:
        $$invalidate(4, slotProps = {
          open: $api.popoverState === PopoverStates.Open,
          close: $api.close
        });
    }
  };
  return [
    as,
    use,
    $api,
    $panelStore,
    slotProps,
    visible,
    forwardEvents,
    api,
    panelStore,
    apiButton,
    openClosedState,
    handleWindowKeydown,
    handleFocus,
    handleKeydown,
    $$restProps,
    focus,
    $openClosedState,
    slots,
    render_el_binding,
    $$scope
  ];
}
var PopoverPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { as: 0, use: 1, focus: 15 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverPanel",
      options,
      id: create_fragment27.name
    });
  }
  get as() {
    throw new Error("<PopoverPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<PopoverPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<PopoverPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<PopoverPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    throw new Error("<PopoverPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focus(value) {
    throw new Error("<PopoverPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverPanel_default = PopoverPanel;

// node_modules/@rgossiaux/svelte-headlessui/components/popover/PopoverButton.svelte
var { window: window_15 } = globals;
var get_default_slot_spread_changes21 = (dirty) => dirty & /*slotProps*/
16;
var get_default_slot_changes22 = (dirty) => ({});
var get_default_slot_context22 = (ctx) => ({ .../*slotProps*/
ctx[4] });
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_default_slot_context22
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        2097168)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            get_default_slot_spread_changes21(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_default_slot_changes22
            ),
            get_default_slot_context22
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: '(184:0) <Render   {...$$restProps}   {...propsWeControl}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"PopoverButton\\"}   bind:el={$ourStore}   on:click={handleClick}   on:keydown={handleKeyDown}   on:keyup={handleKeyUp} >',
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let render;
  let updating_el;
  let current;
  let mounted;
  let dispose;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[14],
    /*propsWeControl*/
    ctx[5],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[4]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "PopoverButton" }
  ];
  function render_el_binding(value) {
    ctx[20](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$ourStore*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*$ourStore*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[13]
  );
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[11]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_15,
          "focus",
          /*handleFocus*/
          ctx[10],
          true,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      16499 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        16384 && get_spread_object(
          /*$$restProps*/
          ctx2[14]
        ),
        dirty & /*propsWeControl*/
        32 && get_spread_object(
          /*propsWeControl*/
          ctx2[5]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        16 && { slotProps: (
          /*slotProps*/
          ctx2[4]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        render_spread_levels[5]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      2097168) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$ourStore*/
      4) {
        updating_el = true;
        render_changes.el = /*$ourStore*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let type;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $apiPanel;
  let $ourStore, $$unsubscribe_ourStore = noop, $$subscribe_ourStore = () => ($$unsubscribe_ourStore(), $$unsubscribe_ourStore = subscribe(ourStore, ($$value) => $$invalidate(2, $ourStore = $$value)), ourStore);
  let $apiButton;
  $$self.$$.on_destroy.push(() => $$unsubscribe_ourStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopoverButton", slots, ["default"]);
  let { as = "button" } = $$props;
  let { use = [] } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = usePopoverContext("PopoverButton");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(17, $api = value));
  let apiButton = $api.button;
  validate_store(apiButton, "apiButton");
  component_subscribe($$self, apiButton, (value) => $$invalidate(24, $apiButton = value));
  let ourStore = apiButton;
  validate_store(ourStore, "ourStore");
  $$subscribe_ourStore();
  let groupContext = usePopoverGroupContext();
  let closeOthers = groupContext == null ? void 0 : groupContext.closeOthers;
  let panelContext = usePopoverPanelContext();
  let isWithinPanel = panelContext === null ? false : panelContext === $api.panelId;
  if (isWithinPanel) {
    $$subscribe_ourStore(ourStore = writable());
  }
  let apiPanel = $api.panel;
  validate_store(apiPanel, "apiPanel");
  component_subscribe($$self, apiPanel, (value) => $$invalidate(18, $apiPanel = value));
  let activeElementRef = null;
  let previousActiveElementRef = typeof window === "undefined" ? null : document.activeElement;
  function handleFocus(event) {
    if (event.target === window.document.body) {
      return;
    }
    previousActiveElementRef = activeElementRef;
    activeElementRef = document.activeElement;
  }
  function handleKeyDown(e) {
    let event = e;
    if (isWithinPanel) {
      if ($api.popoverState === PopoverStates.Closed)
        return;
      switch (event.key) {
        case Keys.Space:
        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();
          $api.closePopover();
          $apiButton == null ? void 0 : $apiButton.focus();
          break;
      }
    } else {
      switch (event.key) {
        case Keys.Space:
        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();
          if ($api.popoverState === PopoverStates.Closed)
            closeOthers == null ? void 0 : closeOthers(
              $api.buttonId
            );
          $api.togglePopover();
          break;
        case Keys.Escape:
          if ($api.popoverState !== PopoverStates.Open)
            return closeOthers == null ? void 0 : closeOthers($api.buttonId);
          if (!$api.button)
            return;
          if (!($apiButton == null ? void 0 : $apiButton.contains(document.activeElement)))
            return;
          event.preventDefault();
          event.stopPropagation();
          $api.closePopover();
          break;
        case Keys.Tab:
          if ($api.popoverState !== PopoverStates.Open)
            return;
          if (!$apiPanel)
            return;
          if (!$apiButton)
            return;
          if (event.shiftKey) {
            if (!previousActiveElementRef)
              return;
            if ($apiButton == null ? void 0 : $apiButton.contains(previousActiveElementRef))
              return;
            if ($apiPanel == null ? void 0 : $apiPanel.contains(previousActiveElementRef))
              return;
            let focusableElements = getFocusableElements();
            let previousIdx = focusableElements.indexOf(previousActiveElementRef);
            let buttonIdx = focusableElements.indexOf($apiButton);
            if (buttonIdx > previousIdx)
              return;
            event.preventDefault();
            event.stopPropagation();
            focusIn($apiPanel, Focus.Last);
          } else {
            event.preventDefault();
            event.stopPropagation();
            focusIn($apiPanel, Focus.First);
          }
          break;
      }
    }
  }
  function handleKeyUp(e) {
    let event = e;
    if (isWithinPanel)
      return;
    if (event.key === Keys.Space) {
      event.preventDefault();
    }
    if ($api.popoverState !== PopoverStates.Open)
      return;
    if (!$apiPanel)
      return;
    if (!$apiButton)
      return;
    switch (event.key) {
      case Keys.Tab:
        if (!previousActiveElementRef)
          return;
        if ($apiButton == null ? void 0 : $apiButton.contains(previousActiveElementRef))
          return;
        if ($apiPanel == null ? void 0 : $apiPanel.contains(previousActiveElementRef))
          return;
        let focusableElements = getFocusableElements();
        let previousIdx = focusableElements.indexOf(previousActiveElementRef);
        let buttonIdx = focusableElements.indexOf($apiButton);
        if (buttonIdx > previousIdx)
          return;
        event.preventDefault();
        event.stopPropagation();
        focusIn($apiPanel, Focus.Last);
        break;
    }
  }
  function handleClick2() {
    if (disabled)
      return;
    if (isWithinPanel) {
      $api.closePopover();
      $apiButton == null ? void 0 : $apiButton.focus();
    } else {
      if ($api.popoverState === PopoverStates.Closed)
        closeOthers == null ? void 0 : closeOthers($api.buttonId);
      $apiButton == null ? void 0 : $apiButton.focus();
      $api.togglePopover();
    }
  }
  function render_el_binding(value) {
    $ourStore = value;
    ourStore.set($ourStore);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$new_props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Keys,
    getFocusableElements,
    Focus,
    focusIn,
    writable,
    PopoverStates,
    usePopoverContext,
    usePopoverGroupContext,
    usePopoverPanelContext,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    resolveButtonType,
    as,
    use,
    disabled,
    forwardEvents,
    api,
    apiButton,
    ourStore,
    groupContext,
    closeOthers,
    panelContext,
    isWithinPanel,
    apiPanel,
    activeElementRef,
    previousActiveElementRef,
    handleFocus,
    handleKeyDown,
    handleKeyUp,
    handleClick: handleClick2,
    slotProps,
    type,
    propsWeControl,
    $api,
    $apiPanel,
    $ourStore,
    $apiButton
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("api" in $$props)
      $$invalidate(7, api = $$new_props.api);
    if ("apiButton" in $$props)
      $$invalidate(8, apiButton = $$new_props.apiButton);
    if ("ourStore" in $$props)
      $$subscribe_ourStore($$invalidate(3, ourStore = $$new_props.ourStore));
    if ("groupContext" in $$props)
      groupContext = $$new_props.groupContext;
    if ("closeOthers" in $$props)
      closeOthers = $$new_props.closeOthers;
    if ("panelContext" in $$props)
      panelContext = $$new_props.panelContext;
    if ("isWithinPanel" in $$props)
      $$invalidate(28, isWithinPanel = $$new_props.isWithinPanel);
    if ("apiPanel" in $$props)
      $$invalidate(9, apiPanel = $$new_props.apiPanel);
    if ("activeElementRef" in $$props)
      activeElementRef = $$new_props.activeElementRef;
    if ("previousActiveElementRef" in $$props)
      previousActiveElementRef = $$new_props.previousActiveElementRef;
    if ("slotProps" in $$props)
      $$invalidate(4, slotProps = $$new_props.slotProps);
    if ("type" in $$props)
      $$invalidate(16, type = $$new_props.type);
    if ("propsWeControl" in $$props)
      $$invalidate(5, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(16, type = resolveButtonType({ type: $$props.type, as }, $ourStore));
    if ($$self.$$.dirty & /*type, $api, disabled, $apiPanel*/
    491520) {
      $:
        $$invalidate(5, propsWeControl = isWithinPanel ? { type } : {
          id: $api.buttonId,
          type,
          "aria-expanded": disabled ? void 0 : $api.popoverState === PopoverStates.Open,
          "aria-controls": $apiPanel ? $api.panelId : void 0,
          disabled: disabled ? true : void 0
        });
    }
    if ($$self.$$.dirty & /*$api*/
    131072) {
      $:
        $$invalidate(4, slotProps = {
          open: $api.popoverState === PopoverStates.Open
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    $ourStore,
    ourStore,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    apiButton,
    apiPanel,
    handleFocus,
    handleKeyDown,
    handleKeyUp,
    handleClick2,
    $$restProps,
    disabled,
    type,
    $api,
    $apiPanel,
    slots,
    render_el_binding,
    $$scope
  ];
}
var PopoverButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { as: 0, use: 1, disabled: 15 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopoverButton",
      options,
      id: create_fragment28.name
    });
  }
  get as() {
    throw new Error("<PopoverButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<PopoverButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<PopoverButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<PopoverButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PopoverButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PopoverButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopoverButton_default = PopoverButton;

// node_modules/@rgossiaux/svelte-headlessui/components/label/LabelProvider.svelte
var get_default_slot_changes23 = (dirty) => ({ labelledby: dirty & /*$contextStore*/
1 });
var get_default_slot_context23 = (ctx) => ({
  labelledby: (
    /*$contextStore*/
    ctx[0].labelIds
  )
});
function create_fragment29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context23
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $contextStore*/
        33)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes23
            ),
            get_default_slot_context23
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var LABEL_CONTEXT_NAME = "headlessui-label-context";
function useLabelContext() {
  return getContext(LABEL_CONTEXT_NAME);
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "slotProps"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LabelProvider", slots, ["default"]);
  let { name } = $$props;
  let { slotProps = {} } = $$props;
  let labelIds = [];
  let contextStore = writable({
    name,
    slotProps,
    props: $$restProps,
    register
  });
  validate_store(contextStore, "contextStore");
  component_subscribe($$self, contextStore, (value) => $$invalidate(0, $contextStore = value));
  setContext(LABEL_CONTEXT_NAME, contextStore);
  function register(value) {
    $$invalidate(4, labelIds = [...labelIds, value]);
    return () => {
      $$invalidate(4, labelIds = labelIds.filter((labelId) => labelId !== value));
    };
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<LabelProvider> was created without expected prop 'name'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("slotProps" in $$new_props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    LABEL_CONTEXT_NAME,
    useLabelContext,
    getContext,
    setContext,
    writable,
    name,
    slotProps,
    labelIds,
    contextStore,
    register,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("labelIds" in $$props)
      $$invalidate(4, labelIds = $$new_props.labelIds);
    if ("contextStore" in $$props)
      $$invalidate(1, contextStore = $$new_props.contextStore);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      contextStore.set({
        name,
        slotProps,
        props: $$restProps,
        register,
        labelIds: labelIds.length > 0 ? labelIds.join(" ") : void 0
      });
  };
  return [$contextStore, contextStore, name, slotProps, labelIds, $$scope, slots];
}
var LabelProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { name: 2, slotProps: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LabelProvider",
      options,
      id: create_fragment29.name
    });
  }
  get name() {
    throw new Error("<LabelProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<LabelProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotProps() {
    throw new Error("<LabelProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotProps(value) {
    throw new Error("<LabelProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LabelProvider_default = LabelProvider;

// node_modules/@rgossiaux/svelte-headlessui/components/radio-group/RadioGroup.svelte
var { Error: Error_18 } = globals;
var get_default_slot_spread_changes22 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes24 = (dirty) => ({});
var get_default_slot_context24 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_default_slot_22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context24
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        16392)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            get_default_slot_spread_changes22(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes24
            ),
            get_default_slot_context24
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(144:4) <Render       {...{ ...$$restProps, ...propsWeControl }}       {as}       use={[...use, forwardEvents]}       {slotProps}       name={\\"RadioGroup\\"}       bind:el={radioGroupRef}       aria-labelledby={labelledby}       aria-describedby={describedby}       on:keydown={handleKeyDown}     >',
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[8],
      .../*propsWeControl*/
      ctx[4]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[5]
      ]
    },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    { name: "RadioGroup" },
    {
      "aria-labelledby": (
        /*labelledby*/
        ctx[18]
      )
    },
    {
      "aria-describedby": (
        /*describedby*/
        ctx[17]
      )
    }
  ];
  function render_el_binding(value) {
    ctx[13](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*radioGroupRef*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*radioGroupRef*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[7]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, use, forwardEvents, slotProps, labelledby, describedby*/
      393531 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        272 && {
          .../*$$restProps*/
          ctx2[8],
          .../*propsWeControl*/
          ctx2[4]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        34 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[5]
          ]
        },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        render_spread_levels[4],
        dirty & /*labelledby*/
        262144 && {
          "aria-labelledby": (
            /*labelledby*/
            ctx2[18]
          )
        },
        dirty & /*describedby*/
        131072 && {
          "aria-describedby": (
            /*describedby*/
            ctx2[17]
          )
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      16392) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*radioGroupRef*/
      4) {
        updating_el = true;
        render_changes.el = /*radioGroupRef*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(143:2) <LabelProvider name=\\"RadioGroupLabel\\" let:labelledby>',
    ctx
  });
  return block;
}
function create_default_slot23(ctx) {
  let labelprovider;
  let current;
  labelprovider = new LabelProvider_default({
    props: {
      name: "RadioGroupLabel",
      $$slots: {
        default: [
          create_default_slot_13,
          ({ labelledby }) => ({ 18: labelledby }),
          ({ labelledby }) => labelledby ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(labelprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(labelprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(labelprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const labelprovider_changes = {};
      if (dirty & /*$$scope, $$restProps, propsWeControl, as, use, slotProps, labelledby, describedby, radioGroupRef*/
      409887) {
        labelprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      labelprovider.$set(labelprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(labelprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: '(142:0) <DescriptionProvider name=\\"RadioGroupDescription\\" let:describedby>',
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let descriptionprovider;
  let current;
  descriptionprovider = new DescriptionProvider_default({
    props: {
      name: "RadioGroupDescription",
      $$slots: {
        default: [
          create_default_slot23,
          ({ describedby }) => ({ 17: describedby }),
          ({ describedby }) => describedby ? 131072 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(descriptionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(descriptionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(descriptionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const descriptionprovider_changes = {};
      if (dirty & /*$$scope, $$restProps, propsWeControl, as, use, slotProps, describedby, radioGroupRef*/
      147743) {
        descriptionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      descriptionprovider.$set(descriptionprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(descriptionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(descriptionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(descriptionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var RADIO_GROUP_CONTEXT_NAME = "headlessui-radio-group-context";
function useRadioGroupContext(component) {
  const context = getContext(RADIO_GROUP_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${component} /> is missing a parent <RadioGroup /> component.`);
  }
  return context;
}
function instance30($$self, $$props, $$invalidate) {
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let radioGroupRef = null;
  let options = [];
  let id2 = `headlessui-radiogroup-${useId()}`;
  let api = writable({
    options,
    value,
    disabled,
    firstOption: options.find((option) => !option.propsRef.disabled),
    containsCheckedOption: options.some((option) => option.propsRef.value === value),
    change(nextValue) {
      var _a;
      if (disabled)
        return false;
      if (value === nextValue)
        return false;
      let nextOption = (_a = options.find((option) => option.propsRef.value === nextValue)) == null ? void 0 : _a.propsRef;
      if (nextOption == null ? void 0 : nextOption.disabled)
        return false;
      $$invalidate(9, value = nextValue);
      return true;
    },
    registerOption(action) {
      if (!radioGroupRef) {
        $$invalidate(11, options = [...options, action]);
        return;
      }
      let orderMap = Array.from(radioGroupRef.querySelectorAll('[id^="headlessui-radiogroup-option-"]')).reduce((lookup, element2, index) => Object.assign(lookup, { [element2.id]: index }), {});
      let newOptions = [...options, action];
      newOptions.sort((a, z) => orderMap[a.id] - orderMap[z.id]);
      $$invalidate(11, options = newOptions);
    },
    unregisterOption(id3) {
      $$invalidate(11, options = options.filter((radio) => radio.id !== id3));
    }
  });
  validate_store(api, "api");
  component_subscribe($$self, api, (value2) => $$invalidate(15, $api = value2));
  setContext(RADIO_GROUP_CONTEXT_NAME, api);
  function handleKeyDown(e) {
    let event = e;
    if (!radioGroupRef)
      return;
    if (!radioGroupRef.contains(event.target))
      return;
    let all = options.filter((option) => option.propsRef.disabled === false).map((radio) => radio.element);
    switch (event.key) {
      case Keys.ArrowLeft:
      case Keys.ArrowUp:
        {
          event.preventDefault();
          event.stopPropagation();
          let result = focusIn(all, Focus.Previous | Focus.WrapAround);
          if (result === FocusResult.Success) {
            let activeOption = options.find((option) => option.element === document.activeElement);
            if (activeOption)
              $api.change(activeOption.propsRef.value);
          }
        }
        break;
      case Keys.ArrowRight:
      case Keys.ArrowDown:
        {
          event.preventDefault();
          event.stopPropagation();
          let result = focusIn(all, Focus.Next | Focus.WrapAround);
          if (result === FocusResult.Success) {
            let activeOption = options.find((option) => option.element === document.activeElement);
            if (activeOption)
              $api.change(activeOption.propsRef.value);
          }
        }
        break;
      case Keys.Space:
        {
          event.preventDefault();
          event.stopPropagation();
          let activeOption = options.find((option) => option.element === document.activeElement);
          if (activeOption)
            $api.change(activeOption.propsRef.value);
        }
        break;
    }
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<RadioGroup> was created without expected prop 'value'");
    }
  });
  function render_el_binding(value2) {
    radioGroupRef = value2;
    $$invalidate(2, radioGroupRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(9, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DescriptionProvider: DescriptionProvider_default,
    LabelProvider: LabelProvider_default,
    getContext,
    setContext,
    writable,
    Focus,
    focusIn,
    FocusResult,
    Keys,
    useId,
    RADIO_GROUP_CONTEXT_NAME,
    useRadioGroupContext,
    treeWalker,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    value,
    disabled,
    forwardEvents,
    radioGroupRef,
    options,
    id: id2,
    api,
    handleKeyDown,
    slotProps,
    propsWeControl,
    $api
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(9, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("radioGroupRef" in $$props)
      $$invalidate(2, radioGroupRef = $$new_props.radioGroupRef);
    if ("options" in $$props)
      $$invalidate(11, options = $$new_props.options);
    if ("id" in $$props)
      $$invalidate(16, id2 = $$new_props.id);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*options, value, disabled*/
    3584) {
      $:
        api.update((obj) => {
          return {
            ...obj,
            options,
            value,
            disabled,
            firstOption: options.find((option) => !option.propsRef.disabled),
            containsCheckedOption: options.some((option) => option.propsRef.value === value)
          };
        });
    }
    if ($$self.$$.dirty & /*radioGroupRef*/
    4) {
      $:
        treeWalker({
          container: radioGroupRef,
          accept(node) {
            if (node.getAttribute("role") === "radio")
              return NodeFilter.FILTER_REJECT;
            if (node.hasAttribute("role"))
              return NodeFilter.FILTER_SKIP;
            return NodeFilter.FILTER_ACCEPT;
          },
          walk(node) {
            node.setAttribute("role", "none");
          }
        });
    }
  };
  $:
    $$invalidate(4, propsWeControl = { id: id2, role: "radiogroup" });
  $:
    $$invalidate(3, slotProps = {});
  return [
    as,
    use,
    radioGroupRef,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    handleKeyDown,
    $$restProps,
    value,
    disabled,
    options,
    slots,
    render_el_binding,
    $$scope
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { as: 0, use: 1, value: 9, disabled: 10 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment30.name
    });
  }
  get as() {
    throw new Error_18("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_18("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_18("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_18("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_18("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_18("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error_18("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error_18("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// node_modules/@rgossiaux/svelte-headlessui/components/radio-group/RadioGroupOption.svelte
var get_default_slot_spread_changes23 = (dirty) => dirty & /*slotProps*/
16;
var get_default_slot_changes25 = (dirty) => ({});
var get_default_slot_context25 = (ctx) => ({ .../*slotProps*/
ctx[4] });
function create_default_slot_23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_default_slot_context25
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        8388624)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            get_default_slot_spread_changes23(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_default_slot_changes25
            ),
            get_default_slot_context25
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: '(75:4) <Render       {...{ ...$$restProps, ...propsWeControl }}       {as}       {slotProps}       use={[...use, forwardEvents]}       name={\\"RadioGroupOption\\"}       bind:el={optionRef}       aria-labelledby={labelledby}       aria-describedby={describedby}       on:click={isDisabled ? () => {} : handleClick}       on:focus={isDisabled ? () => {} : handleFocus}       on:blur={isDisabled ? () => {} : handleBlur}     >',
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[11],
      .../*propsWeControl*/
      ctx[5]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[4]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "RadioGroupOption" },
    {
      "aria-labelledby": (
        /*labelledby*/
        ctx[27]
      )
    },
    {
      "aria-describedby": (
        /*describedby*/
        ctx[26]
      )
    }
  ];
  function render_el_binding(value) {
    ctx[22](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot_23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*optionRef*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*optionRef*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on("click", function() {
    if (is_function(
      /*isDisabled*/
      ctx[3] ? click_handler : (
        /*handleClick*/
        ctx[8]
      )
    ))
      /*isDisabled*/
      (ctx[3] ? click_handler : (
        /*handleClick*/
        ctx[8]
      )).apply(this, arguments);
  });
  render.$on("focus", function() {
    if (is_function(
      /*isDisabled*/
      ctx[3] ? focus_handler : (
        /*handleFocus*/
        ctx[9]
      )
    ))
      /*isDisabled*/
      (ctx[3] ? focus_handler : (
        /*handleFocus*/
        ctx[9]
      )).apply(this, arguments);
  });
  render.$on("blur", function() {
    if (is_function(
      /*isDisabled*/
      ctx[3] ? blur_handler : (
        /*handleBlur*/
        ctx[10]
      )
    ))
      /*isDisabled*/
      (ctx[3] ? blur_handler : (
        /*handleBlur*/
        ctx[10]
      )).apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents, labelledby, describedby*/
      201328755 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        2080 && {
          .../*$$restProps*/
          ctx[11],
          .../*propsWeControl*/
          ctx[5]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx[0]
        ) },
        dirty & /*slotProps*/
        16 && { slotProps: (
          /*slotProps*/
          ctx[4]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx[1],
            /*forwardEvents*/
            ctx[6]
          ]
        },
        render_spread_levels[4],
        dirty & /*labelledby*/
        134217728 && {
          "aria-labelledby": (
            /*labelledby*/
            ctx[27]
          )
        },
        dirty & /*describedby*/
        67108864 && {
          "aria-describedby": (
            /*describedby*/
            ctx[26]
          )
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      8388624) {
        render_changes.$$scope = { dirty, ctx };
      }
      if (!updating_el && dirty & /*optionRef*/
      4) {
        updating_el = true;
        render_changes.el = /*optionRef*/
        ctx[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: '(74:2) <LabelProvider name=\\"RadioGroupLabel\\" {slotProps} let:labelledby>',
    ctx
  });
  return block;
}
function create_default_slot24(ctx) {
  let labelprovider;
  let current;
  labelprovider = new LabelProvider_default({
    props: {
      name: "RadioGroupLabel",
      slotProps: (
        /*slotProps*/
        ctx[4]
      ),
      $$slots: {
        default: [
          create_default_slot_14,
          ({ labelledby }) => ({ 27: labelledby }),
          ({ labelledby }) => labelledby ? 134217728 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(labelprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(labelprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(labelprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const labelprovider_changes = {};
      if (dirty & /*slotProps*/
      16)
        labelprovider_changes.slotProps = /*slotProps*/
        ctx2[4];
      if (dirty & /*$$scope, $$restProps, propsWeControl, as, slotProps, use, labelledby, describedby, optionRef, isDisabled*/
      209717311) {
        labelprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      labelprovider.$set(labelprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(labelprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: '(73:0) <DescriptionProvider name=\\"RadioGroupDescription\\" {slotProps} let:describedby>',
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let descriptionprovider;
  let current;
  descriptionprovider = new DescriptionProvider_default({
    props: {
      name: "RadioGroupDescription",
      slotProps: (
        /*slotProps*/
        ctx[4]
      ),
      $$slots: {
        default: [
          create_default_slot24,
          ({ describedby }) => ({ 26: describedby }),
          ({ describedby }) => describedby ? 67108864 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(descriptionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(descriptionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(descriptionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const descriptionprovider_changes = {};
      if (dirty & /*slotProps*/
      16)
        descriptionprovider_changes.slotProps = /*slotProps*/
        ctx2[4];
      if (dirty & /*$$scope, slotProps, $$restProps, propsWeControl, as, use, describedby, optionRef, isDisabled*/
      75499583) {
        descriptionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      descriptionprovider.$set(descriptionprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(descriptionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(descriptionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(descriptionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler = () => {
};
var focus_handler = () => {
};
var blur_handler = () => {
};
function instance31($$self, $$props, $$invalidate) {
  let propsRef;
  let isFirstOption;
  let isDisabled;
  let checked;
  let tabIndex;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroupOption", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  var OptionState;
  (function(OptionState2) {
    OptionState2[OptionState2["Empty"] = 1] = "Empty";
    OptionState2[OptionState2["Active"] = 2] = "Active";
  })(OptionState || (OptionState = {}));
  let api = useRadioGroupContext("RadioGroupOption");
  validate_store(api, "api");
  component_subscribe($$self, api, (value2) => $$invalidate(20, $api = value2));
  let id2 = `headlessui-radiogroup-option-${useId()}`;
  let optionRef = null;
  let state = OptionState.Empty;
  function updateOption(option) {
    $api.unregisterOption(option.id);
    $api.registerOption(option);
  }
  onDestroy(() => $api.unregisterOption(id2));
  function handleClick2() {
    if (!$api.change(value))
      return;
    $$invalidate(15, state |= OptionState.Active);
    optionRef == null ? void 0 : optionRef.focus();
  }
  function handleFocus() {
    $$invalidate(15, state |= OptionState.Active);
  }
  function handleBlur() {
    $$invalidate(15, state &= ~OptionState.Active);
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<RadioGroupOption> was created without expected prop 'value'");
    }
  });
  function render_el_binding(value2) {
    optionRef = value2;
    $$invalidate(2, optionRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(12, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    DescriptionProvider: DescriptionProvider_default,
    LabelProvider: LabelProvider_default,
    useRadioGroupContext,
    useId,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    value,
    disabled,
    forwardEvents,
    OptionState,
    api,
    id: id2,
    optionRef,
    state,
    updateOption,
    handleClick: handleClick2,
    handleFocus,
    handleBlur,
    isDisabled,
    checked,
    slotProps,
    tabIndex,
    propsWeControl,
    isFirstOption,
    propsRef,
    $api
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(12, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("OptionState" in $$props)
      $$invalidate(14, OptionState = $$new_props.OptionState);
    if ("api" in $$props)
      $$invalidate(7, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(24, id2 = $$new_props.id);
    if ("optionRef" in $$props)
      $$invalidate(2, optionRef = $$new_props.optionRef);
    if ("state" in $$props)
      $$invalidate(15, state = $$new_props.state);
    if ("isDisabled" in $$props)
      $$invalidate(3, isDisabled = $$new_props.isDisabled);
    if ("checked" in $$props)
      $$invalidate(16, checked = $$new_props.checked);
    if ("slotProps" in $$props)
      $$invalidate(4, slotProps = $$new_props.slotProps);
    if ("tabIndex" in $$props)
      $$invalidate(17, tabIndex = $$new_props.tabIndex);
    if ("propsWeControl" in $$props)
      $$invalidate(5, propsWeControl = $$new_props.propsWeControl);
    if ("isFirstOption" in $$props)
      $$invalidate(18, isFirstOption = $$new_props.isFirstOption);
    if ("propsRef" in $$props)
      $$invalidate(19, propsRef = $$new_props.propsRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*value, disabled*/
    12288) {
      $:
        $$invalidate(19, propsRef = { value, disabled });
    }
    if ($$self.$$.dirty & /*optionRef, propsRef*/
    524292) {
      $:
        updateOption({ id: id2, element: optionRef, propsRef });
    }
    if ($$self.$$.dirty & /*$api*/
    1048576) {
      $:
        $$invalidate(18, isFirstOption = ((_a = $api.firstOption) == null ? void 0 : _a.id) === id2);
    }
    if ($$self.$$.dirty & /*$api, disabled*/
    1056768) {
      $:
        $$invalidate(3, isDisabled = $api.disabled || disabled);
    }
    if ($$self.$$.dirty & /*$api, value*/
    1052672) {
      $:
        $$invalidate(16, checked = $api.value === value);
    }
    if ($$self.$$.dirty & /*isDisabled, checked, $api, isFirstOption*/
    1376264) {
      $:
        $$invalidate(17, tabIndex = (() => {
          if (isDisabled)
            return -1;
          if (checked)
            return 0;
          if (!$api.containsCheckedOption && isFirstOption)
            return 0;
          return -1;
        })());
    }
    if ($$self.$$.dirty & /*checked, isDisabled, tabIndex*/
    196616) {
      $:
        $$invalidate(5, propsWeControl = {
          id: id2,
          role: "radio",
          "aria-checked": checked ? "true" : "false",
          "aria-disabled": isDisabled ? true : void 0,
          tabIndex
        });
    }
    if ($$self.$$.dirty & /*checked, isDisabled, state, OptionState*/
    114696) {
      $:
        $$invalidate(4, slotProps = {
          checked,
          disabled: isDisabled,
          active: !!(state & OptionState.Active)
        });
    }
  };
  return [
    as,
    use,
    optionRef,
    isDisabled,
    slotProps,
    propsWeControl,
    forwardEvents,
    api,
    handleClick2,
    handleFocus,
    handleBlur,
    $$restProps,
    value,
    disabled,
    OptionState,
    state,
    checked,
    tabIndex,
    isFirstOption,
    propsRef,
    $api,
    slots,
    render_el_binding,
    $$scope
  ];
}
var RadioGroupOption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { as: 0, use: 1, value: 12, disabled: 13 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroupOption",
      options,
      id: create_fragment31.name
    });
  }
  get as() {
    throw new Error("<RadioGroupOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<RadioGroupOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<RadioGroupOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<RadioGroupOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioGroupOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioGroupOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioGroupOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioGroupOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroupOption_default = RadioGroupOption;

// node_modules/@rgossiaux/svelte-headlessui/components/label/Label.svelte
var { Error: Error_19 } = globals;
var get_default_slot_spread_changes24 = (dirty) => dirty & /*slotProps*/
16;
var get_default_slot_changes26 = (dirty) => ({});
var get_default_slot_context26 = (ctx) => ({ .../*slotProps*/
ctx[4] });
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context26
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        1040)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            get_default_slot_spread_changes24(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes26
            ),
            get_default_slot_context26
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: '(24:0) <Render   {...allProps}   name={\\"Label\\"}   {as}   {slotProps}   use={[...use, forwardEvents]}   on:click={(event) => {     if (!passive) allProps[\\"onClick\\"]?.(event);   }} >',
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*allProps*/
    ctx[3],
    { name: "Label" },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[4]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[5]
      ]
    }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  render.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*allProps, as, slotProps, use, forwardEvents*/
      59 ? get_spread_update(render_spread_levels, [
        dirty & /*allProps*/
        8 && get_spread_object(
          /*allProps*/
          ctx2[3]
        ),
        render_spread_levels[1],
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        16 && { slotProps: (
          /*slotProps*/
          ctx2[4]
        ) },
        dirty & /*use, forwardEvents*/
        34 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[5]
          ]
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      1040) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use", "passive"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { as = "label" } = $$props;
  let { use = [] } = $$props;
  const id2 = `headlessui-label-${useId()}`;
  let { passive = false } = $$props;
  let contextStore = useLabelContext();
  validate_store(contextStore, "contextStore");
  component_subscribe($$self, contextStore, (value) => $$invalidate(7, $contextStore = value));
  if (!contextStore) {
    throw new Error("You used a <Label /> component, but it is not inside a relevant parent.");
  }
  onMount(() => $contextStore.register(id2));
  let allProps = {};
  if (passive)
    delete allProps["onClick"];
  const click_handler2 = (event) => {
    var _a;
    if (!passive)
      (_a = allProps["onClick"]) == null ? void 0 : _a.call(allProps, event);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("passive" in $$new_props)
      $$invalidate(2, passive = $$new_props.passive);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Render: Render_default,
    useId,
    forwardEventsBuilder,
    onMount,
    get_current_component,
    useLabelContext,
    forwardEvents,
    as,
    use,
    id: id2,
    passive,
    contextStore,
    allProps,
    slotProps,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("passive" in $$props)
      $$invalidate(2, passive = $$new_props.passive);
    if ("contextStore" in $$props)
      $$invalidate(6, contextStore = $$new_props.contextStore);
    if ("allProps" in $$props)
      $$invalidate(3, allProps = $$new_props.allProps);
    if ("slotProps" in $$props)
      $$invalidate(4, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, allProps = {
        ...$$restProps,
        ...$contextStore.props,
        id: id2
      });
    if ($$self.$$.dirty & /*$contextStore*/
    128) {
      $:
        $$invalidate(4, slotProps = $contextStore.slotProps);
    }
  };
  return [
    as,
    use,
    passive,
    allProps,
    slotProps,
    forwardEvents,
    contextStore,
    $contextStore,
    slots,
    click_handler2,
    $$scope
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { as: 0, use: 1, passive: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment32.name
    });
  }
  get as() {
    throw new Error_19("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_19("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_19("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_19("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passive() {
    throw new Error_19("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passive(value) {
    throw new Error_19("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@rgossiaux/svelte-headlessui/components/switch/SwitchGroup.svelte
var get_default_slot_spread_changes25 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes27 = (dirty) => ({});
var get_default_slot_context27 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot_24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context27
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            get_default_slot_spread_changes25(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes27
            ),
            get_default_slot_context27
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: '(41:4) <LabelProvider name=\\"SwitchLabel\\" {onClick}>',
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let labelprovider;
  let current;
  labelprovider = new LabelProvider_default({
    props: {
      name: "SwitchLabel",
      onClick: (
        /*onClick*/
        ctx[5]
      ),
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(labelprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(labelprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(labelprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const labelprovider_changes = {};
      if (dirty & /*$$scope, slotProps*/
      260) {
        labelprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      labelprovider.$set(labelprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(labelprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: '(40:2) <DescriptionProvider name=\\"SwitchDescription\\">',
    ctx
  });
  return block;
}
function create_default_slot26(ctx) {
  let descriptionprovider;
  let current;
  descriptionprovider = new DescriptionProvider_default({
    props: {
      name: "SwitchDescription",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(descriptionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(descriptionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(descriptionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const descriptionprovider_changes = {};
      if (dirty & /*$$scope, slotProps*/
      260) {
        descriptionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      descriptionprovider.$set(descriptionprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(descriptionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(descriptionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(descriptionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: '(33:0) <Render   {...$$restProps}   {as}   use={[...use, forwardEvents]}   {slotProps}   name={\\"SwitchGroup\\"} >',
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[6],
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    { name: "SwitchGroup" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, use, forwardEvents, slotProps*/
      79 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      260) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var SWITCH_CONTEXT_NAME = "headlessui-switch-context";
function useSwitchContext() {
  return getContext(SWITCH_CONTEXT_NAME);
}
function instance33($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $switchStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SwitchGroup", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let switchStore = writable(null);
  validate_store(switchStore, "switchStore");
  component_subscribe($$self, switchStore, (value) => $$invalidate(9, $switchStore = value));
  let api = writable({ switchStore });
  setContext(SWITCH_CONTEXT_NAME, api);
  function onClick() {
    if (!$switchStore)
      return;
    $switchStore.click();
    $switchStore.focus({ preventScroll: true });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    SWITCH_CONTEXT_NAME,
    useSwitchContext,
    DescriptionProvider: DescriptionProvider_default,
    LabelProvider: LabelProvider_default,
    getContext,
    setContext,
    writable,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    switchStore,
    api,
    onClick,
    slotProps,
    $switchStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("switchStore" in $$props)
      $$invalidate(4, switchStore = $$new_props.switchStore);
    if ("api" in $$props)
      api = $$new_props.api;
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(2, slotProps = {});
  return [
    as,
    use,
    slotProps,
    forwardEvents,
    switchStore,
    onClick,
    $$restProps,
    slots,
    $$scope
  ];
}
var SwitchGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SwitchGroup",
      options,
      id: create_fragment33.name
    });
  }
  get as() {
    throw new Error("<SwitchGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<SwitchGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<SwitchGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<SwitchGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SwitchGroup_default = SwitchGroup;

// node_modules/@rgossiaux/svelte-headlessui/components/switch/Switch.svelte
var get_default_slot_spread_changes_12 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes_12 = (dirty) => ({});
var get_default_slot_context_12 = (ctx) => ({ .../*slotProps*/
ctx[3] });
var get_default_slot_spread_changes26 = (dirty) => dirty & /*slotProps*/
8;
var get_default_slot_changes28 = (dirty) => ({});
var get_default_slot_context28 = (ctx) => ({ .../*slotProps*/
ctx[3] });
function create_else_block3(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[12],
      .../*propsWeControl*/
      ctx[4]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "Switch" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot_16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  render.$on(
    "click",
    /*handleClick*/
    ctx[10]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[11]
  );
  render.$on("keypress", handleKeyPress);
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      4187 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        4112 && {
          .../*$$restProps*/
          ctx2[12],
          .../*propsWeControl*/
          ctx2[4]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524296) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(71:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[12],
      .../*propsWeControl*/
      ctx[4]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[3]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "Switch" }
  ];
  function render_el_binding(value) {
    ctx[18](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$switchStore*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*$switchStore*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "click",
    /*handleClick*/
    ctx[10]
  );
  render.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[11]
  );
  render.$on("keypress", handleKeyPress);
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      4187 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        4112 && {
          .../*$$restProps*/
          ctx2[12],
          .../*propsWeControl*/
          ctx2[4]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        8 && { slotProps: (
          /*slotProps*/
          ctx2[3]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524296) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$switchStore*/
      4) {
        updating_el = true;
        render_changes.el = /*$switchStore*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(57:0) {#if switchStore}",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context_12
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524296)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes_12(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes_12
            ),
            get_default_slot_context_12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: '(72:2) <Render     {...{ ...$$restProps, ...propsWeControl }}     {as}     {slotProps}     use={[...use, forwardEvents]}     name={\\"Switch\\"}     on:click={handleClick}     on:keyup={handleKeyUp}     on:keypress={handleKeyPress}   >',
    ctx
  });
  return block;
}
function create_default_slot27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context28
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524296)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes26(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes28
            ),
            get_default_slot_context28
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: '(58:2) <Render     {...{ ...$$restProps, ...propsWeControl }}     {as}     {slotProps}     use={[...use, forwardEvents]}     name={\\"Switch\\"}     bind:el={$switchStore}     on:click={handleClick}     on:keyup={handleKeyUp}     on:keypress={handleKeyPress}   >',
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*switchStore*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function handleKeyPress(e) {
  let event = e;
  event.preventDefault();
}
function instance34($$self, $$props, $$invalidate) {
  let switchStore;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "checked"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $descriptionContext;
  let $labelContext;
  let $switchStore, $$unsubscribe_switchStore = noop, $$subscribe_switchStore = () => ($$unsubscribe_switchStore(), $$unsubscribe_switchStore = subscribe(switchStore, ($$value) => $$invalidate(2, $switchStore = $$value)), switchStore);
  let $api;
  $$self.$$.on_destroy.push(() => $$unsubscribe_switchStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, ["default"]);
  let { as = "button" } = $$props;
  let { use = [] } = $$props;
  let { checked = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useSwitchContext();
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(16, $api = value));
  let labelContext = useLabelContext();
  validate_store(labelContext, "labelContext");
  component_subscribe($$self, labelContext, (value) => $$invalidate(15, $labelContext = value));
  let descriptionContext = useDescriptionContext();
  validate_store(descriptionContext, "descriptionContext");
  component_subscribe($$self, descriptionContext, (value) => $$invalidate(14, $descriptionContext = value));
  let id2 = `headlessui-switch-${useId()}`;
  function toggle() {
    $$invalidate(13, checked = !checked);
  }
  function handleClick2(e) {
    let event = e;
    event.preventDefault();
    toggle();
  }
  function handleKeyUp(e) {
    let event = e;
    if (event.key !== Keys.Tab)
      event.preventDefault();
    if (event.key === Keys.Space)
      toggle();
  }
  function render_el_binding(value) {
    $switchStore = value;
    switchStore.set($switchStore);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("checked" in $$new_props)
      $$invalidate(13, checked = $$new_props.checked);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useSwitchContext,
    useLabelContext,
    useDescriptionContext,
    useId,
    Keys,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    resolveButtonType,
    as,
    use,
    checked,
    forwardEvents,
    api,
    labelContext,
    descriptionContext,
    id: id2,
    toggle,
    handleClick: handleClick2,
    handleKeyUp,
    handleKeyPress,
    slotProps,
    propsWeControl,
    switchStore,
    $descriptionContext,
    $labelContext,
    $switchStore,
    $api
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("checked" in $$props)
      $$invalidate(13, checked = $$new_props.checked);
    if ("api" in $$props)
      $$invalidate(7, api = $$new_props.api);
    if ("labelContext" in $$props)
      $$invalidate(8, labelContext = $$new_props.labelContext);
    if ("descriptionContext" in $$props)
      $$invalidate(9, descriptionContext = $$new_props.descriptionContext);
    if ("id" in $$props)
      $$invalidate(20, id2 = $$new_props.id);
    if ("slotProps" in $$props)
      $$invalidate(3, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(4, propsWeControl = $$new_props.propsWeControl);
    if ("switchStore" in $$props)
      $$subscribe_switchStore($$invalidate(5, switchStore = $$new_props.switchStore));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    65536) {
      $:
        $$subscribe_switchStore($$invalidate(5, switchStore = $api == null ? void 0 : $api.switchStore));
    }
    $:
      $$invalidate(4, propsWeControl = {
        id: id2,
        role: "switch",
        type: resolveButtonType({ type: $$props.type, as }, $switchStore),
        tabIndex: 0,
        "aria-checked": checked,
        "aria-labelledby": $labelContext == null ? void 0 : $labelContext.labelIds,
        "aria-describedby": $descriptionContext == null ? void 0 : $descriptionContext.descriptionIds
      });
    if ($$self.$$.dirty & /*checked*/
    8192) {
      $:
        $$invalidate(3, slotProps = { checked });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    $switchStore,
    slotProps,
    propsWeControl,
    switchStore,
    forwardEvents,
    api,
    labelContext,
    descriptionContext,
    handleClick2,
    handleKeyUp,
    $$restProps,
    checked,
    $descriptionContext,
    $labelContext,
    $api,
    slots,
    render_el_binding,
    $$scope
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { as: 0, use: 1, checked: 13 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment34.name
    });
  }
  get as() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/@rgossiaux/svelte-headlessui/components/tabs/TabGroup.svelte
var { Error: Error_110 } = globals;
var get_default_slot_spread_changes27 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes29 = (dirty) => ({});
var get_default_slot_context29 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context29
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        8196)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            get_default_slot_spread_changes27(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes29
            ),
            get_default_slot_context29
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot28.name,
    type: "slot",
    source: '(116:0) <Render   {...$$restProps}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"TabGroup\\"} >',
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[5],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { name: "TabGroup" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot28] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, slotProps, use, forwardEvents*/
      47 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      8196) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var TABS_CONTEXT_NAME = "headlessui-tabs-context";
function useTabsContext(component) {
  let context = getContext(TABS_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error(`<${component} /> is missing a parent <TabGroup /> component.`);
  }
  return context;
}
function instance35($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use", "defaultIndex", "vertical", "manual"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $listRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabGroup", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { defaultIndex = 0 } = $$props;
  let { vertical = false } = $$props;
  let { manual = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component(), ["change"]);
  const dispatch = createEventDispatcher();
  let selectedIndex = null;
  let tabs = [];
  let panels = [];
  let listRef = writable(null);
  validate_store(listRef, "listRef");
  component_subscribe($$self, listRef, (value) => $$invalidate(14, $listRef = value));
  let api = writable({
    selectedIndex,
    orientation: vertical ? "vertical" : "horizontal",
    activation: manual ? "manual" : "auto",
    tabs,
    panels,
    listRef,
    setSelectedIndex(index) {
      if (selectedIndex === index)
        return;
      $$invalidate(9, selectedIndex = index);
      dispatch("change", index);
    },
    registerTab(tab) {
      if (tabs.includes(tab))
        return;
      if (!$listRef) {
        $$invalidate(10, tabs = [...tabs, tab]);
        return;
      }
      let currentSelectedTab = selectedIndex !== null ? tabs[selectedIndex] : null;
      let orderMap = Array.from($listRef.querySelectorAll('[id^="headlessui-tabs-tab-"]')).reduce((lookup, element2, index) => Object.assign(lookup, { [element2.id]: index }), {});
      let nextTabs = [...tabs, tab];
      nextTabs.sort((a, z) => orderMap[a.id] - orderMap[z.id]);
      $$invalidate(10, tabs = nextTabs);
      $$invalidate(9, selectedIndex = (() => {
        if (currentSelectedTab === null)
          return null;
        return tabs.indexOf(currentSelectedTab);
      })());
    },
    unregisterTab(tab) {
      $$invalidate(10, tabs = tabs.filter((t) => t !== tab));
    },
    registerPanel(panel) {
      if (!panels.includes(panel))
        $$invalidate(11, panels = [...panels, panel]);
    },
    unregisterPanel(panel) {
      $$invalidate(11, panels = panels.filter((p) => p !== panel));
    }
  });
  setContext(TABS_CONTEXT_NAME, api);
  onMount(() => {
    if (tabs.length <= 0)
      return;
    if (selectedIndex !== null)
      return;
    let mountedTabs = tabs.filter(Boolean);
    let focusableTabs = mountedTabs.filter((tab) => !tab.hasAttribute("disabled"));
    if (focusableTabs.length <= 0)
      return;
    if (defaultIndex < 0) {
      $$invalidate(9, selectedIndex = mountedTabs.indexOf(focusableTabs[0]));
    } else if (defaultIndex > mountedTabs.length) {
      $$invalidate(9, selectedIndex = mountedTabs.indexOf(focusableTabs[focusableTabs.length - 1]));
    } else {
      let before = mountedTabs.slice(0, defaultIndex);
      let after = mountedTabs.slice(defaultIndex);
      let next = [...after, ...before].find((tab) => focusableTabs.includes(tab));
      if (!next)
        return;
      $$invalidate(9, selectedIndex = mountedTabs.indexOf(next));
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("defaultIndex" in $$new_props)
      $$invalidate(6, defaultIndex = $$new_props.defaultIndex);
    if ("vertical" in $$new_props)
      $$invalidate(7, vertical = $$new_props.vertical);
    if ("manual" in $$new_props)
      $$invalidate(8, manual = $$new_props.manual);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    TABS_CONTEXT_NAME,
    useTabsContext,
    createEventDispatcher,
    getContext,
    onMount,
    setContext,
    writable,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    defaultIndex,
    vertical,
    manual,
    forwardEvents,
    dispatch,
    selectedIndex,
    tabs,
    panels,
    listRef,
    api,
    slotProps,
    $listRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("defaultIndex" in $$props)
      $$invalidate(6, defaultIndex = $$new_props.defaultIndex);
    if ("vertical" in $$props)
      $$invalidate(7, vertical = $$new_props.vertical);
    if ("manual" in $$props)
      $$invalidate(8, manual = $$new_props.manual);
    if ("selectedIndex" in $$props)
      $$invalidate(9, selectedIndex = $$new_props.selectedIndex);
    if ("tabs" in $$props)
      $$invalidate(10, tabs = $$new_props.tabs);
    if ("panels" in $$props)
      $$invalidate(11, panels = $$new_props.panels);
    if ("listRef" in $$props)
      $$invalidate(4, listRef = $$new_props.listRef);
    if ("api" in $$props)
      $$invalidate(16, api = $$new_props.api);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectedIndex, vertical, manual, tabs, panels*/
    3968) {
      $:
        api.update((obj) => {
          return {
            ...obj,
            selectedIndex,
            orientation: vertical ? "vertical" : "horizontal",
            activation: manual ? "manual" : "auto",
            tabs,
            panels
          };
        });
    }
    if ($$self.$$.dirty & /*selectedIndex*/
    512) {
      $:
        $$invalidate(2, slotProps = { selectedIndex });
    }
  };
  return [
    as,
    use,
    slotProps,
    forwardEvents,
    listRef,
    $$restProps,
    defaultIndex,
    vertical,
    manual,
    selectedIndex,
    tabs,
    panels,
    slots,
    $$scope
  ];
}
var TabGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      as: 0,
      use: 1,
      defaultIndex: 6,
      vertical: 7,
      manual: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabGroup",
      options,
      id: create_fragment35.name
    });
  }
  get as() {
    throw new Error_110("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_110("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_110("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_110("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultIndex() {
    throw new Error_110("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultIndex(value) {
    throw new Error_110("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error_110("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error_110("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get manual() {
    throw new Error_110("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set manual(value) {
    throw new Error_110("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabGroup_default = TabGroup;

// node_modules/@rgossiaux/svelte-headlessui/components/tabs/Tab.svelte
var get_default_slot_spread_changes28 = (dirty) => dirty & /*slotProps*/
32;
var get_default_slot_changes30 = (dirty) => ({});
var get_default_slot_context30 = (ctx) => ({ .../*slotProps*/
ctx[5] });
function create_default_slot29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context30
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        524320)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            get_default_slot_spread_changes28(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes30
            ),
            get_default_slot_context30
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot29.name,
    type: "slot",
    source: '(92:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"Tab\\"}   bind:el={tabRef}   on:keydown={handleKeyDown}   on:click={handleSelection}   on:focus={$api.activation === \\"manual\\" ? handleFocus : handleSelection} >',
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[12],
      .../*propsWeControl*/
      ctx[3]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[5]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[7]
      ]
    },
    { name: "Tab" }
  ];
  function render_el_binding(value) {
    ctx[18](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot29] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*tabRef*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*tabRef*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  render.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[9]
  );
  render.$on(
    "click",
    /*handleSelection*/
    ctx[11]
  );
  render.$on("focus", function() {
    if (is_function(
      /*$api*/
      ctx[4].activation === "manual" ? (
        /*handleFocus*/
        ctx[10]
      ) : (
        /*handleSelection*/
        ctx[11]
      )
    ))
      /*$api*/
      (ctx[4].activation === "manual" ? (
        /*handleFocus*/
        ctx[10]
      ) : (
        /*handleSelection*/
        ctx[11]
      )).apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      4267 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        4104 && {
          .../*$$restProps*/
          ctx[12],
          .../*propsWeControl*/
          ctx[3]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx[0]
        ) },
        dirty & /*slotProps*/
        32 && { slotProps: (
          /*slotProps*/
          ctx[5]
        ) },
        dirty & /*use, forwardEvents*/
        130 && {
          use: [
            .../*use*/
            ctx[1],
            /*forwardEvents*/
            ctx[7]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      524320) {
        render_changes.$$scope = { dirty, ctx };
      }
      if (!updating_el && dirty & /*tabRef*/
      4) {
        updating_el = true;
        render_changes.el = /*tabRef*/
        ctx[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let myIndex;
  let selected;
  let myPanelRef;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $myPanelRef, $$unsubscribe_myPanelRef = noop, $$subscribe_myPanelRef = () => ($$unsubscribe_myPanelRef(), $$unsubscribe_myPanelRef = subscribe(myPanelRef, ($$value) => $$invalidate(16, $myPanelRef = $$value)), myPanelRef);
  $$self.$$.on_destroy.push(() => $$unsubscribe_myPanelRef());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  let { as = "button" } = $$props;
  let { use = [] } = $$props;
  let { disabled = false } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useTabsContext("Tab");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(4, $api = value));
  let id2 = `headlessui-tabs-tab-${useId()}`;
  let tabRef = null;
  onMount(() => {
    $api.registerTab(tabRef);
    return () => $api.unregisterTab(tabRef);
  });
  function handleKeyDown(e) {
    let event = e;
    let list = $api.tabs.filter(Boolean);
    if (event.key === Keys.Space || event.key === Keys.Enter) {
      event.preventDefault();
      event.stopPropagation();
      $api.setSelectedIndex(myIndex);
      return;
    }
    switch (event.key) {
      case Keys.Home:
      case Keys.PageUp:
        event.preventDefault();
        event.stopPropagation();
        return focusIn(list, Focus.First);
      case Keys.End:
      case Keys.PageDown:
        event.preventDefault();
        event.stopPropagation();
        return focusIn(list, Focus.Last);
    }
    return match($api.orientation, {
      vertical() {
        if (event.key === Keys.ArrowUp)
          return focusIn(list, Focus.Previous | Focus.WrapAround);
        if (event.key === Keys.ArrowDown)
          return focusIn(list, Focus.Next | Focus.WrapAround);
        return;
      },
      horizontal() {
        if (event.key === Keys.ArrowLeft)
          return focusIn(list, Focus.Previous | Focus.WrapAround);
        if (event.key === Keys.ArrowRight)
          return focusIn(list, Focus.Next | Focus.WrapAround);
        return;
      }
    });
  }
  function handleFocus() {
    tabRef == null ? void 0 : tabRef.focus();
  }
  function handleSelection() {
    if (disabled)
      return;
    tabRef == null ? void 0 : tabRef.focus();
    $api.setSelectedIndex(myIndex);
  }
  function render_el_binding(value) {
    tabRef = value;
    $$invalidate(2, tabRef);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$new_props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    Focus,
    focusIn,
    Keys,
    match,
    useTabsContext,
    useId,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    resolveButtonType,
    as,
    use,
    disabled,
    forwardEvents,
    api,
    id: id2,
    tabRef,
    handleKeyDown,
    handleFocus,
    handleSelection,
    selected,
    slotProps,
    myIndex,
    propsWeControl,
    myPanelRef,
    $api,
    $myPanelRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("disabled" in $$props)
      $$invalidate(13, disabled = $$new_props.disabled);
    if ("api" in $$props)
      $$invalidate(8, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(20, id2 = $$new_props.id);
    if ("tabRef" in $$props)
      $$invalidate(2, tabRef = $$new_props.tabRef);
    if ("selected" in $$props)
      $$invalidate(14, selected = $$new_props.selected);
    if ("slotProps" in $$props)
      $$invalidate(5, slotProps = $$new_props.slotProps);
    if ("myIndex" in $$props)
      $$invalidate(15, myIndex = $$new_props.myIndex);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
    if ("myPanelRef" in $$props)
      $$subscribe_myPanelRef($$invalidate(6, myPanelRef = $$new_props.myPanelRef));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty & /*tabRef, $api*/
    20) {
      $:
        $$invalidate(15, myIndex = tabRef ? $api.tabs.indexOf(tabRef) : -1);
    }
    if ($$self.$$.dirty & /*myIndex, $api*/
    32784) {
      $:
        $$invalidate(14, selected = myIndex === $api.selectedIndex);
    }
    if ($$self.$$.dirty & /*$api, myIndex*/
    32784) {
      $:
        $$subscribe_myPanelRef($$invalidate(6, myPanelRef = (_a = $api.panels[myIndex]) == null ? void 0 : _a.ref));
    }
    $:
      $$invalidate(3, propsWeControl = {
        id: id2,
        role: "tab",
        type: resolveButtonType({ type: $$props.type, as }, tabRef),
        "aria-controls": $myPanelRef ? (_b = $api.panels[myIndex]) == null ? void 0 : _b.id : void 0,
        "aria-selected": selected,
        tabIndex: selected ? 0 : -1,
        disabled: disabled ? true : void 0
      });
    if ($$self.$$.dirty & /*propsWeControl, myIndex*/
    32776) {
      $:
        if (false) {
          Object.assign(propsWeControl, { ["data-headlessui-index"]: myIndex });
        }
    }
    if ($$self.$$.dirty & /*selected*/
    16384) {
      $:
        $$invalidate(5, slotProps = { selected });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    tabRef,
    propsWeControl,
    $api,
    slotProps,
    myPanelRef,
    forwardEvents,
    api,
    handleKeyDown,
    handleFocus,
    handleSelection,
    $$restProps,
    disabled,
    selected,
    myIndex,
    $myPanelRef,
    slots,
    render_el_binding,
    $$scope
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { as: 0, use: 1, disabled: 13 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment36.name
    });
  }
  get as() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@rgossiaux/svelte-headlessui/components/tabs/TabList.svelte
var get_default_slot_spread_changes29 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes31 = (dirty) => ({});
var get_default_slot_context31 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot30(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context31
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        4100)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            get_default_slot_spread_changes29(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes31
            ),
            get_default_slot_context31
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot30.name,
    type: "slot",
    source: '(22:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   {slotProps}   bind:el={$listRef}   use={[...use, forwardEvents]}   name={\\"TabList\\"} >',
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[8],
      .../*propsWeControl*/
      ctx[3]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[5]
      ]
    },
    { name: "TabList" }
  ];
  function render_el_binding(value) {
    ctx[11](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot30] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$listRef*/
    ctx[4] !== void 0
  ) {
    render_props.el = /*$listRef*/
    ctx[4];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, slotProps, use, forwardEvents*/
      303 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        264 && {
          .../*$$restProps*/
          ctx2[8],
          .../*propsWeControl*/
          ctx2[3]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        34 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[5]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      4100) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$listRef*/
      16) {
        updating_el = true;
        render_changes.el = /*$listRef*/
        ctx2[4];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $listRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabList", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useTabsContext("TabList");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(9, $api = value));
  let listRef = $api.listRef;
  validate_store(listRef, "listRef");
  component_subscribe($$self, listRef, (value) => $$invalidate(4, $listRef = value));
  function render_el_binding(value) {
    $listRef = value;
    listRef.set($listRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTabsContext,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    api,
    listRef,
    slotProps,
    propsWeControl,
    $api,
    $listRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(6, api = $$new_props.api);
    if ("listRef" in $$props)
      $$invalidate(7, listRef = $$new_props.listRef);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    512) {
      $:
        $$invalidate(3, propsWeControl = {
          role: "tablist",
          "aria-orientation": $api.orientation
        });
    }
    if ($$self.$$.dirty & /*$api*/
    512) {
      $:
        $$invalidate(2, slotProps = { selectedIndex: $api.selectedIndex });
    }
  };
  return [
    as,
    use,
    slotProps,
    propsWeControl,
    $listRef,
    forwardEvents,
    api,
    listRef,
    $$restProps,
    $api,
    slots,
    render_el_binding,
    $$scope
  ];
}
var TabList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabList",
      options,
      id: create_fragment37.name
    });
  }
  get as() {
    throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabList_default = TabList;

// node_modules/@rgossiaux/svelte-headlessui/components/tabs/TabPanels.svelte
var get_default_slot_spread_changes30 = (dirty) => dirty & /*slotProps*/
4;
var get_default_slot_changes32 = (dirty) => ({});
var get_default_slot_context32 = (ctx) => ({ .../*slotProps*/
ctx[2] });
function create_default_slot31(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context32
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            get_default_slot_spread_changes30(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes32
            ),
            get_default_slot_context32
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot31.name,
    type: "slot",
    source: '(17:0) <Render   {...$$restProps}   {as}   {slotProps}   use={[...use, forwardEvents]}   name={\\"TabPanels\\"} >',
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let render;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[5],
    { as: (
      /*as*/
      ctx[0]
    ) },
    { slotProps: (
      /*slotProps*/
      ctx[2]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    },
    { name: "TabPanels" }
  ];
  let render_props = {
    $$slots: { default: [create_default_slot31] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  render = new Render_default({ props: render_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, as, slotProps, use, forwardEvents*/
      47 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*slotProps*/
        4 && { slotProps: (
          /*slotProps*/
          ctx2[2]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        },
        render_spread_levels[4]
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      260) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPanels", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let api = useTabsContext("TabPanels");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(6, $api = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useTabsContext,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    as,
    use,
    forwardEvents,
    api,
    slotProps,
    $api
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("api" in $$props)
      $$invalidate(4, api = $$new_props.api);
    if ("slotProps" in $$props)
      $$invalidate(2, slotProps = $$new_props.slotProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$api*/
    64) {
      $:
        $$invalidate(2, slotProps = { selectedIndex: $api.selectedIndex });
    }
  };
  return [as, use, slotProps, forwardEvents, api, $$restProps, $api, slots, $$scope];
}
var TabPanels = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPanels",
      options,
      id: create_fragment38.name
    });
  }
  get as() {
    throw new Error("<TabPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<TabPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<TabPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TabPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabPanels_default = TabPanels;

// node_modules/@rgossiaux/svelte-headlessui/components/tabs/TabPanel.svelte
var get_default_slot_spread_changes31 = (dirty) => dirty & /*slotProps*/
16;
var get_default_slot_changes33 = (dirty) => ({});
var get_default_slot_context33 = (ctx) => ({ .../*slotProps*/
ctx[4] });
function create_default_slot32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context33
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slotProps*/
        32784)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            get_default_slot_spread_changes31(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes33
            ),
            get_default_slot_context33
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot32.name,
    type: "slot",
    source: '(39:0) <Render   {...{ ...$$restProps, ...propsWeControl }}   {as}   use={[...use, forwardEvents]}   name={\\"TabPanel\\"}   {slotProps}   bind:el={$elementRef}   visible={selected}   features={Features.RenderStrategy | Features.Static} >',
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    {
      .../*$$restProps*/
      ctx[9],
      .../*propsWeControl*/
      ctx[3]
    },
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[6]
      ]
    },
    { name: "TabPanel" },
    { slotProps: (
      /*slotProps*/
      ctx[4]
    ) },
    { visible: (
      /*selected*/
      ctx[2]
    ) },
    {
      features: Features.RenderStrategy | Features.Static
    }
  ];
  function render_el_binding(value) {
    ctx[14](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot32] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*$elementRef*/
    ctx[5] !== void 0
  ) {
    render_props.el = /*$elementRef*/
    ctx[5];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const render_changes = dirty & /*$$restProps, propsWeControl, as, use, forwardEvents, slotProps, selected, Features*/
      607 ? get_spread_update(render_spread_levels, [
        dirty & /*$$restProps, propsWeControl*/
        520 && {
          .../*$$restProps*/
          ctx2[9],
          .../*propsWeControl*/
          ctx2[3]
        },
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        66 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[6]
          ]
        },
        render_spread_levels[3],
        dirty & /*slotProps*/
        16 && { slotProps: (
          /*slotProps*/
          ctx2[4]
        ) },
        dirty & /*selected*/
        4 && { visible: (
          /*selected*/
          ctx2[2]
        ) },
        dirty & /*Features*/
        0 && {
          features: Features.RenderStrategy | Features.Static
        }
      ]) : {};
      if (dirty & /*$$scope, slotProps*/
      32784) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty & /*$elementRef*/
      32) {
        updating_el = true;
        render_changes.el = /*$elementRef*/
        ctx2[5];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let panelData;
  let myIndex;
  let selected;
  let propsWeControl;
  let slotProps;
  const omit_props_names = ["as", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $api;
  let $elementRef;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPanel", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let elementRef = writable(null);
  validate_store(elementRef, "elementRef");
  component_subscribe($$self, elementRef, (value) => $$invalidate(5, $elementRef = value));
  let api = useTabsContext("TabPanel");
  validate_store(api, "api");
  component_subscribe($$self, api, (value) => $$invalidate(12, $api = value));
  let id2 = `headlessui-tabs-panel-${useId()}`;
  onMount(() => {
    $api.registerPanel(panelData);
    return () => $api.unregisterPanel(panelData);
  });
  function render_el_binding(value) {
    $elementRef = value;
    elementRef.set($elementRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    useTabsContext,
    useId,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    writable,
    Features,
    as,
    use,
    forwardEvents,
    elementRef,
    api,
    id: id2,
    selected,
    slotProps,
    myIndex,
    propsWeControl,
    panelData,
    $api,
    $elementRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("elementRef" in $$props)
      $$invalidate(7, elementRef = $$new_props.elementRef);
    if ("api" in $$props)
      $$invalidate(8, api = $$new_props.api);
    if ("id" in $$props)
      $$invalidate(16, id2 = $$new_props.id);
    if ("selected" in $$props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("slotProps" in $$props)
      $$invalidate(4, slotProps = $$new_props.slotProps);
    if ("myIndex" in $$props)
      $$invalidate(10, myIndex = $$new_props.myIndex);
    if ("propsWeControl" in $$props)
      $$invalidate(3, propsWeControl = $$new_props.propsWeControl);
    if ("panelData" in $$props)
      $$invalidate(11, panelData = $$new_props.panelData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*$api, panelData*/
    6144) {
      $:
        $$invalidate(10, myIndex = $api.panels.indexOf(panelData));
    }
    if ($$self.$$.dirty & /*myIndex, $api*/
    5120) {
      $:
        $$invalidate(2, selected = myIndex === $api.selectedIndex);
    }
    if ($$self.$$.dirty & /*$api, myIndex, selected*/
    5124) {
      $:
        $$invalidate(3, propsWeControl = {
          id: id2,
          role: "tabpanel",
          "aria-labelledby": (_a = $api.tabs[myIndex]) == null ? void 0 : _a.id,
          tabIndex: selected ? 0 : -1
        });
    }
    if ($$self.$$.dirty & /*propsWeControl, myIndex*/
    1032) {
      $:
        if (false) {
          Object.assign(propsWeControl, { ["data-headlessui-index"]: myIndex });
        }
    }
    if ($$self.$$.dirty & /*selected*/
    4) {
      $:
        $$invalidate(4, slotProps = { selected });
    }
  };
  $:
    $$invalidate(11, panelData = { id: id2, ref: elementRef });
  return [
    as,
    use,
    selected,
    propsWeControl,
    slotProps,
    $elementRef,
    forwardEvents,
    elementRef,
    api,
    $$restProps,
    myIndex,
    panelData,
    $api,
    slots,
    render_el_binding,
    $$scope
  ];
}
var TabPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPanel",
      options,
      id: create_fragment39.name
    });
  }
  get as() {
    throw new Error("<TabPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<TabPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<TabPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TabPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabPanel_default = TabPanel;

// node_modules/@rgossiaux/svelte-headlessui/utils/once.js
function once(cb) {
  let state = { called: false };
  return (...args) => {
    if (state.called)
      return;
    state.called = true;
    return cb(...args);
  };
}

// node_modules/@rgossiaux/svelte-headlessui/utils/disposables.js
function disposables() {
  let disposables2 = [];
  let api = {
    requestAnimationFrame(...args) {
      let raf = requestAnimationFrame(...args);
      api.add(() => cancelAnimationFrame(raf));
    },
    nextFrame(...args) {
      api.requestAnimationFrame(() => {
        api.requestAnimationFrame(...args);
      });
    },
    setTimeout(...args) {
      let timer = setTimeout(...args);
      api.add(() => clearTimeout(timer));
    },
    add(cb) {
      disposables2.push(cb);
    },
    dispose() {
      for (let dispose of disposables2.splice(0)) {
        dispose();
      }
    }
  };
  return api;
}

// node_modules/@rgossiaux/svelte-headlessui/utils/transition.js
function addClasses(node, ...classes) {
  node && classes.length > 0 && node.classList.add(...classes);
}
function removeClasses(node, ...classes) {
  node && classes.length > 0 && node.classList.remove(...classes);
}
var Reason;
(function(Reason2) {
  Reason2["Finished"] = "finished";
  Reason2["Cancelled"] = "cancelled";
})(Reason || (Reason = {}));
function waitForTransition(node, done) {
  let d = disposables();
  if (!node)
    return d.dispose;
  let { transitionDuration, transitionDelay } = getComputedStyle(node);
  let [durationMs, delaysMs] = [transitionDuration, transitionDelay].map((value) => {
    let [resolvedValue = 0] = value.split(",").filter(Boolean).map((v) => v.includes("ms") ? parseFloat(v) : parseFloat(v) * 1e3).sort((a, z) => z - a);
    return resolvedValue;
  });
  if (durationMs !== 0) {
    d.setTimeout(() => {
      done(Reason.Finished);
    }, durationMs + delaysMs);
  } else {
    done(Reason.Finished);
  }
  d.add(() => done(Reason.Cancelled));
  return d.dispose;
}
function transition(node, base, from, to, entered, done) {
  let d = disposables();
  let _done = done !== void 0 ? once(done) : () => {
  };
  removeClasses(node, ...entered);
  addClasses(node, ...base, ...from);
  d.nextFrame(() => {
    removeClasses(node, ...from);
    addClasses(node, ...to);
    d.add(waitForTransition(node, (reason) => {
      removeClasses(node, ...to, ...base);
      addClasses(node, ...entered);
      return _done(reason);
    }));
  });
  d.add(() => removeClasses(node, ...base, ...from, ...to));
  d.add(() => _done(Reason.Cancelled));
  return d.dispose;
}

// node_modules/@rgossiaux/svelte-headlessui/components/transitions/common.svelte
var TreeStates;
(function(TreeStates2) {
  TreeStates2["Visible"] = "visible";
  TreeStates2["Hidden"] = "hidden";
})(TreeStates || (TreeStates = {}));
var TRANSITION_CONTEXT_NAME = "headlessui-transition-context";
var NESTING_CONTEXT_NAME = "headlessui-nesting-context";
function hasTransitionContext() {
  return getContext(TRANSITION_CONTEXT_NAME) !== void 0;
}
function useTransitionContext() {
  let context = getContext(TRANSITION_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  }
  return context;
}
function useParentNesting() {
  let context = getContext(NESTING_CONTEXT_NAME);
  if (context === void 0) {
    throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  }
  return context;
}
function hasChildren(bag) {
  if ("children" in bag)
    return hasChildren(bag.children);
  return bag.filter(({ state }) => state === TreeStates.Visible).length > 0;
}
function useNesting(done) {
  let transitionableChildren = [];
  function unregister(childId, strategy = RenderStrategy.Hidden) {
    let idx = transitionableChildren.findIndex(({ id: id2 }) => id2 === childId);
    if (idx === -1)
      return;
    let hadChildren = hasChildren(transitionableChildren);
    match(strategy, {
      [RenderStrategy.Unmount]() {
        transitionableChildren.splice(idx, 1);
      },
      [RenderStrategy.Hidden]() {
        transitionableChildren[idx].state = TreeStates.Hidden;
      }
    });
    if (hadChildren && !hasChildren(transitionableChildren)) {
      done == null ? void 0 : done();
    }
  }
  function register(childId) {
    let child = transitionableChildren.find(({ id: id2 }) => id2 === childId);
    if (!child) {
      transitionableChildren.push({ id: childId, state: TreeStates.Visible });
    } else if (child.state !== TreeStates.Visible) {
      child.state = TreeStates.Visible;
    }
    return () => unregister(childId, RenderStrategy.Unmount);
  }
  return {
    children: transitionableChildren,
    register,
    unregister
  };
}

// node_modules/@rgossiaux/svelte-headlessui/components/transitions/TransitionChild.svelte
function create_default_slot33(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot33.name,
    type: "slot",
    source: '(142:0) <Render   {...$$restProps}   {as}   use={[...use, forwardEvents]}   slotProps={{}}   name={\\"TransitionChild\\"}   bind:el={container}   class={classes}   visible={state === TreeStates.Visible}   features={Features.RenderStrategy} >',
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let render;
  let updating_el;
  let current;
  const render_spread_levels = [
    /*$$restProps*/
    ctx[9],
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[5]
      ]
    },
    { slotProps: {} },
    { name: "TransitionChild" },
    { class: (
      /*classes*/
      ctx[4]
    ) },
    {
      visible: (
        /*state*/
        ctx[3] === TreeStates.Visible
      )
    },
    { features: Features.RenderStrategy }
  ];
  function render_el_binding(value) {
    ctx[24](value);
  }
  let render_props = {
    $$slots: { default: [create_default_slot33] },
    $$scope: { ctx }
  };
  for (let i = 0; i < render_spread_levels.length; i += 1) {
    render_props = assign(render_props, render_spread_levels[i]);
  }
  if (
    /*container*/
    ctx[2] !== void 0
  ) {
    render_props.el = /*container*/
    ctx[2];
  }
  render = new Render_default({ props: render_props, $$inline: true });
  binding_callbacks.push(() => bind(render, "el", render_el_binding));
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = dirty[0] & /*$$restProps, as, use, forwardEvents, classes, state*/
      571 ? get_spread_update(render_spread_levels, [
        dirty[0] & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx2[9]
        ),
        dirty[0] & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty[0] & /*use, forwardEvents*/
        34 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[5]
          ]
        },
        render_spread_levels[3],
        render_spread_levels[4],
        dirty[0] & /*classes*/
        16 && { class: (
          /*classes*/
          ctx2[4]
        ) },
        dirty[0] & /*state*/
        8 && {
          visible: (
            /*state*/
            ctx2[3] === TreeStates.Visible
          )
        },
        dirty & /*Features*/
        0 && { features: Features.RenderStrategy }
      ]) : {};
      if (dirty[0] & /*$$scope*/
      33554432) {
        render_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_el && dirty[0] & /*container*/
      4) {
        updating_el = true;
        render_changes.el = /*container*/
        ctx2[2];
        add_flush_callback(() => updating_el = false);
      }
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let strategy;
  let enterClasses;
  let enterFromClasses;
  let enterToClasses;
  let enteredClasses;
  let leaveClasses;
  let leaveFromClasses;
  let leaveToClasses;
  let classes;
  const omit_props_names = [
    "as",
    "use",
    "enter",
    "enterFrom",
    "enterTo",
    "entered",
    "leave",
    "leaveFrom",
    "leaveTo"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $transitionContext;
  let $nestingContext;
  let $nesting;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransitionChild", slots, ["default"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { enter = "" } = $$props;
  let { enterFrom = "" } = $$props;
  let { enterTo = "" } = $$props;
  let { entered = "" } = $$props;
  let { leave = "" } = $$props;
  let { leaveFrom = "" } = $$props;
  let { leaveTo = "" } = $$props;
  const dispatch = createEventDispatcher();
  const forwardEvents = forwardEventsBuilder(get_current_component(), ["introstart", "introend", "outrostart", "outroend"]);
  let container = null;
  let transitionContext = useTransitionContext();
  validate_store(transitionContext, "transitionContext");
  component_subscribe($$self, transitionContext, (value) => $$invalidate(21, $transitionContext = value));
  let nestingContext = useParentNesting();
  validate_store(nestingContext, "nestingContext");
  component_subscribe($$self, nestingContext, (value) => $$invalidate(22, $nestingContext = value));
  let state = $transitionContext.initialShow || $$props.unmount !== false ? TreeStates.Visible : TreeStates.Hidden;
  let initial = true;
  let id2 = useId();
  let isTransitioning = false;
  let nesting = writable(useNesting(() => {
    if (!isTransitioning) {
      $$invalidate(3, state = TreeStates.Hidden);
      $nestingContext.unregister(id2);
      dispatch("outroend");
    }
  }));
  validate_store(nesting, "nesting");
  component_subscribe($$self, nesting, (value) => $$invalidate(34, $nesting = value));
  onMount(() => $nestingContext.register(id2));
  function splitClasses(classes2 = "") {
    return classes2.split(" ").filter((className) => className.trim().length > 1);
  }
  let mounted = false;
  onMount(() => $$invalidate(18, mounted = true));
  function executeTransition(show, appear) {
    let skip = initial && !appear;
    let node = container;
    if (!node || !(node instanceof HTMLElement))
      return;
    if (skip)
      return;
    $$invalidate(17, isTransitioning = true);
    if (show)
      dispatch("introstart");
    if (!show)
      dispatch("outrostart");
    return show ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, (reason) => {
      $$invalidate(17, isTransitioning = false);
      if (reason === Reason.Finished)
        dispatch("introend");
    }) : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, (reason) => {
      $$invalidate(17, isTransitioning = false);
      if (reason !== Reason.Finished)
        return;
      if (!hasChildren($nesting)) {
        $$invalidate(3, state = TreeStates.Hidden);
        $nestingContext.unregister(id2);
        dispatch("outroend");
      }
    });
  }
  let _cleanup = null;
  setContext(NESTING_CONTEXT_NAME, nesting);
  let openClosedState = writable(State.Closed);
  useOpenClosedProvider(openClosedState);
  function render_el_binding(value) {
    container = value;
    $$invalidate(2, container);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("enter" in $$new_props)
      $$invalidate(10, enter = $$new_props.enter);
    if ("enterFrom" in $$new_props)
      $$invalidate(11, enterFrom = $$new_props.enterFrom);
    if ("enterTo" in $$new_props)
      $$invalidate(12, enterTo = $$new_props.enterTo);
    if ("entered" in $$new_props)
      $$invalidate(13, entered = $$new_props.entered);
    if ("leave" in $$new_props)
      $$invalidate(14, leave = $$new_props.leave);
    if ("leaveFrom" in $$new_props)
      $$invalidate(15, leaveFrom = $$new_props.leaveFrom);
    if ("leaveTo" in $$new_props)
      $$invalidate(16, leaveTo = $$new_props.leaveTo);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    setContext,
    writable,
    match,
    State,
    useOpenClosedProvider,
    Reason,
    transition,
    hasChildren,
    NESTING_CONTEXT_NAME,
    TreeStates,
    useNesting,
    useParentNesting,
    useTransitionContext,
    useId,
    forwardEventsBuilder,
    get_current_component,
    Render: Render_default,
    RenderStrategy,
    Features,
    as,
    use,
    enter,
    enterFrom,
    enterTo,
    entered,
    leave,
    leaveFrom,
    leaveTo,
    dispatch,
    forwardEvents,
    container,
    transitionContext,
    nestingContext,
    state,
    initial,
    id: id2,
    isTransitioning,
    nesting,
    splitClasses,
    mounted,
    executeTransition,
    _cleanup,
    openClosedState,
    classes,
    enteredClasses,
    leaveToClasses,
    leaveFromClasses,
    leaveClasses,
    enterToClasses,
    enterFromClasses,
    enterClasses,
    strategy,
    $transitionContext,
    $nestingContext,
    $nesting
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("enter" in $$props)
      $$invalidate(10, enter = $$new_props.enter);
    if ("enterFrom" in $$props)
      $$invalidate(11, enterFrom = $$new_props.enterFrom);
    if ("enterTo" in $$props)
      $$invalidate(12, enterTo = $$new_props.enterTo);
    if ("entered" in $$props)
      $$invalidate(13, entered = $$new_props.entered);
    if ("leave" in $$props)
      $$invalidate(14, leave = $$new_props.leave);
    if ("leaveFrom" in $$props)
      $$invalidate(15, leaveFrom = $$new_props.leaveFrom);
    if ("leaveTo" in $$props)
      $$invalidate(16, leaveTo = $$new_props.leaveTo);
    if ("container" in $$props)
      $$invalidate(2, container = $$new_props.container);
    if ("transitionContext" in $$props)
      $$invalidate(6, transitionContext = $$new_props.transitionContext);
    if ("nestingContext" in $$props)
      $$invalidate(7, nestingContext = $$new_props.nestingContext);
    if ("state" in $$props)
      $$invalidate(3, state = $$new_props.state);
    if ("initial" in $$props)
      initial = $$new_props.initial;
    if ("id" in $$props)
      $$invalidate(36, id2 = $$new_props.id);
    if ("isTransitioning" in $$props)
      $$invalidate(17, isTransitioning = $$new_props.isTransitioning);
    if ("nesting" in $$props)
      $$invalidate(8, nesting = $$new_props.nesting);
    if ("mounted" in $$props)
      $$invalidate(18, mounted = $$new_props.mounted);
    if ("_cleanup" in $$props)
      $$invalidate(19, _cleanup = $$new_props._cleanup);
    if ("openClosedState" in $$props)
      $$invalidate(39, openClosedState = $$new_props.openClosedState);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("enteredClasses" in $$props)
      enteredClasses = $$new_props.enteredClasses;
    if ("leaveToClasses" in $$props)
      leaveToClasses = $$new_props.leaveToClasses;
    if ("leaveFromClasses" in $$props)
      leaveFromClasses = $$new_props.leaveFromClasses;
    if ("leaveClasses" in $$props)
      leaveClasses = $$new_props.leaveClasses;
    if ("enterToClasses" in $$props)
      enterToClasses = $$new_props.enterToClasses;
    if ("enterFromClasses" in $$props)
      enterFromClasses = $$new_props.enterFromClasses;
    if ("enterClasses" in $$props)
      enterClasses = $$new_props.enterClasses;
    if ("strategy" in $$props)
      $$invalidate(20, strategy = $$new_props.strategy);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(20, strategy = $$props.unmount === false ? RenderStrategy.Hidden : RenderStrategy.Unmount);
    if ($$self.$$.dirty[0] & /*strategy, $transitionContext, state, $nestingContext*/
    7340040) {
      $: {
        (() => {
          if (strategy !== RenderStrategy.Hidden)
            return;
          if (!id2)
            return;
          if ($transitionContext.show && state !== TreeStates.Visible) {
            $$invalidate(3, state = TreeStates.Visible);
            return;
          }
          match(state, {
            [TreeStates.Hidden]: () => $nestingContext.unregister(id2),
            [TreeStates.Visible]: () => $nestingContext.register(id2)
          });
        })();
      }
    }
    if ($$self.$$.dirty[0] & /*enter*/
    1024) {
      $:
        enterClasses = splitClasses(enter);
    }
    if ($$self.$$.dirty[0] & /*enterFrom*/
    2048) {
      $:
        enterFromClasses = splitClasses(enterFrom);
    }
    if ($$self.$$.dirty[0] & /*enterTo*/
    4096) {
      $:
        enterToClasses = splitClasses(enterTo);
    }
    if ($$self.$$.dirty[0] & /*entered*/
    8192) {
      $:
        enteredClasses = splitClasses(entered);
    }
    if ($$self.$$.dirty[0] & /*leave*/
    16384) {
      $:
        leaveClasses = splitClasses(leave);
    }
    if ($$self.$$.dirty[0] & /*leaveFrom*/
    32768) {
      $:
        leaveFromClasses = splitClasses(leaveFrom);
    }
    if ($$self.$$.dirty[0] & /*leaveTo*/
    65536) {
      $:
        leaveToClasses = splitClasses(leaveTo);
    }
    if ($$self.$$.dirty[0] & /*mounted, _cleanup, $transitionContext*/
    2883584) {
      $: {
        if (mounted) {
          if (_cleanup) {
            _cleanup();
          }
          $$invalidate(19, _cleanup = executeTransition($transitionContext.show, $transitionContext.appear));
          initial = false;
        }
      }
    }
    if ($$self.$$.dirty[0] & /*state*/
    8) {
      $:
        openClosedState.set(match(state, {
          [TreeStates.Visible]: State.Open,
          [TreeStates.Hidden]: State.Closed
        }));
    }
    $:
      $$invalidate(4, classes = isTransitioning ? container == null ? void 0 : container.className : `${$$props.class || ""} ${entered}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    container,
    state,
    classes,
    forwardEvents,
    transitionContext,
    nestingContext,
    nesting,
    $$restProps,
    enter,
    enterFrom,
    enterTo,
    entered,
    leave,
    leaveFrom,
    leaveTo,
    isTransitioning,
    mounted,
    _cleanup,
    strategy,
    $transitionContext,
    $nestingContext,
    slots,
    render_el_binding,
    $$scope
  ];
}
var TransitionChild = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance40,
      create_fragment40,
      safe_not_equal,
      {
        as: 0,
        use: 1,
        enter: 10,
        enterFrom: 11,
        enterTo: 12,
        entered: 13,
        leave: 14,
        leaveFrom: 15,
        leaveTo: 16
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransitionChild",
      options,
      id: create_fragment40.name
    });
  }
  get as() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enter() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enter(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enterFrom() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enterFrom(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enterTo() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enterTo(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get entered() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set entered(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leave() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leave(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leaveFrom() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leaveFrom(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leaveTo() {
    throw new Error("<TransitionChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leaveTo(value) {
    throw new Error("<TransitionChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransitionChild_default = TransitionChild;

// node_modules/@rgossiaux/svelte-headlessui/components/transitions/TransitionRoot.svelte
var { Error: Error_111 } = globals;
function create_if_block4(ctx) {
  let transitionchild;
  let current;
  const transitionchild_spread_levels = [
    /*$$restProps*/
    ctx[7],
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[3]
      ]
    }
  ];
  let transitionchild_props = {
    $$slots: { default: [create_default_slot34] },
    $$scope: { ctx }
  };
  for (let i = 0; i < transitionchild_spread_levels.length; i += 1) {
    transitionchild_props = assign(transitionchild_props, transitionchild_spread_levels[i]);
  }
  transitionchild = new TransitionChild_default({
    props: transitionchild_props,
    $$inline: true
  });
  transitionchild.$on(
    "introstart",
    /*introstart_handler*/
    ctx[15]
  );
  transitionchild.$on(
    "introend",
    /*introend_handler*/
    ctx[16]
  );
  transitionchild.$on(
    "outrostart",
    /*outrostart_handler*/
    ctx[17]
  );
  transitionchild.$on(
    "outroend",
    /*outroend_handler*/
    ctx[18]
  );
  const block = {
    c: function create() {
      create_component(transitionchild.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(transitionchild.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(transitionchild, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transitionchild_changes = dirty & /*$$restProps, as, use, forwardEvents*/
      139 ? get_spread_update(transitionchild_spread_levels, [
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        10 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[3]
          ]
        }
      ]) : {};
      if (dirty & /*$$scope*/
      524288) {
        transitionchild_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transitionchild.$set(transitionchild_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(transitionchild.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(transitionchild.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(transitionchild, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(68:0) {#if state === TreeStates.Visible || $$props.unmount === false}",
    ctx
  });
  return block;
}
function create_default_slot34(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot34.name,
    type: "slot",
    source: "(69:2) <TransitionChild     {...$$restProps}     {as}     use={[...use, forwardEvents]}     on:introstart     on:introend     on:outrostart     on:outroend   >",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*state*/
    (ctx[2] === TreeStates.Visible || /*$$props*/
    ctx[6].unmount === false) && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*state*/
        ctx2[2] === TreeStates.Visible || /*$$props*/
        ctx2[6].unmount === false
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*state, $$props*/
          68) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  const omit_props_names = ["as", "use", "show", "appear"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $nestingBag;
  let $openClosedState;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransitionRoot", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component(), ["introstart", "introend", "outrostart", "outroend"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let { show = void 0 } = $$props;
  let { appear = false } = $$props;
  let openClosedState = useOpenClosed();
  validate_store(openClosedState, "openClosedState");
  component_subscribe($$self, openClosedState, (value) => $$invalidate(13, $openClosedState = value));
  function computeShow(show2, openClosedState2) {
    if (show2 === void 0 && openClosedState2 !== void 0) {
      return match(openClosedState2, {
        [State.Open]: true,
        [State.Closed]: false
      });
    }
    return show2;
  }
  let shouldShow = computeShow(show, openClosedState !== void 0 ? $openClosedState : void 0);
  let initialShow = shouldShow;
  let state = shouldShow ? TreeStates.Visible : TreeStates.Hidden;
  let nestingBag = writable(useNesting(() => {
    $$invalidate(2, state = TreeStates.Hidden);
  }));
  validate_store(nestingBag, "nestingBag");
  component_subscribe($$self, nestingBag, (value) => $$invalidate(12, $nestingBag = value));
  let initial = true;
  let transitionBag = writable();
  onMount(() => {
    $$invalidate(11, initial = false);
  });
  setContext(NESTING_CONTEXT_NAME, nestingBag);
  setContext(TRANSITION_CONTEXT_NAME, transitionBag);
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("show" in $$new_props)
      $$invalidate(8, show = $$new_props.show);
    if ("appear" in $$new_props)
      $$invalidate(9, appear = $$new_props.appear);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    writable,
    match,
    State,
    useOpenClosed,
    TransitionChild: TransitionChild_default,
    forwardEventsBuilder,
    get_current_component,
    hasChildren,
    NESTING_CONTEXT_NAME,
    TRANSITION_CONTEXT_NAME,
    TreeStates,
    useNesting,
    forwardEvents,
    as,
    use,
    show,
    appear,
    openClosedState,
    computeShow,
    shouldShow,
    initialShow,
    state,
    nestingBag,
    initial,
    transitionBag,
    $nestingBag,
    $openClosedState
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("show" in $$props)
      $$invalidate(8, show = $$new_props.show);
    if ("appear" in $$props)
      $$invalidate(9, appear = $$new_props.appear);
    if ("openClosedState" in $$props)
      $$invalidate(4, openClosedState = $$new_props.openClosedState);
    if ("shouldShow" in $$props)
      $$invalidate(10, shouldShow = $$new_props.shouldShow);
    if ("initialShow" in $$props)
      $$invalidate(21, initialShow = $$new_props.initialShow);
    if ("state" in $$props)
      $$invalidate(2, state = $$new_props.state);
    if ("nestingBag" in $$props)
      $$invalidate(5, nestingBag = $$new_props.nestingBag);
    if ("initial" in $$props)
      $$invalidate(11, initial = $$new_props.initial);
    if ("transitionBag" in $$props)
      $$invalidate(22, transitionBag = $$new_props.transitionBag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*show, $openClosedState, shouldShow*/
    9472) {
      $: {
        $$invalidate(10, shouldShow = computeShow(show, openClosedState !== void 0 ? $openClosedState : void 0));
        if (shouldShow !== true && shouldShow !== false) {
          throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
        }
      }
    }
    if ($$self.$$.dirty & /*shouldShow, appear, initial*/
    3584) {
      $:
        transitionBag.set({
          show: !!shouldShow,
          appear: appear || !initial,
          initialShow: !!initialShow
        });
    }
    if ($$self.$$.dirty & /*initial, shouldShow, $nestingBag*/
    7168) {
      $:
        if (!initial) {
          if (shouldShow) {
            $$invalidate(2, state = TreeStates.Visible);
          } else if (!hasChildren($nestingBag)) {
            $$invalidate(2, state = TreeStates.Hidden);
          }
        }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    state,
    forwardEvents,
    openClosedState,
    nestingBag,
    $$props,
    $$restProps,
    show,
    appear,
    shouldShow,
    initial,
    $nestingBag,
    $openClosedState,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    $$scope
  ];
}
var TransitionRoot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, { as: 0, use: 1, show: 8, appear: 9 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransitionRoot",
      options,
      id: create_fragment41.name
    });
  }
  get as() {
    throw new Error_111("<TransitionRoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_111("<TransitionRoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error_111("<TransitionRoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_111("<TransitionRoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get show() {
    throw new Error_111("<TransitionRoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set show(value) {
    throw new Error_111("<TransitionRoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appear() {
    throw new Error_111("<TransitionRoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appear(value) {
    throw new Error_111("<TransitionRoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransitionRoot_default = TransitionRoot;

// node_modules/@rgossiaux/svelte-headlessui/components/transitions/TransitionChildWrapper.svelte
function create_else_block4(ctx) {
  let transitionchild;
  let current;
  const transitionchild_spread_levels = [
    /*$$props*/
    ctx[5],
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[2]
      ]
    }
  ];
  let transitionchild_props = {
    $$slots: { default: [create_default_slot_17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < transitionchild_spread_levels.length; i += 1) {
    transitionchild_props = assign(transitionchild_props, transitionchild_spread_levels[i]);
  }
  transitionchild = new TransitionChild_default({
    props: transitionchild_props,
    $$inline: true
  });
  transitionchild.$on(
    "introstart",
    /*introstart_handler_1*/
    ctx[11]
  );
  transitionchild.$on(
    "introend",
    /*introend_handler_1*/
    ctx[12]
  );
  transitionchild.$on(
    "outrostart",
    /*outrostart_handler_1*/
    ctx[13]
  );
  transitionchild.$on(
    "outroend",
    /*outroend_handler_1*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(transitionchild.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(transitionchild.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(transitionchild, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transitionchild_changes = dirty & /*$$props, as, use, forwardEvents*/
      39 ? get_spread_update(transitionchild_spread_levels, [
        dirty & /*$$props*/
        32 && get_spread_object(
          /*$$props*/
          ctx2[5]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        6 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[2]
          ]
        }
      ]) : {};
      if (dirty & /*$$scope*/
      32768) {
        transitionchild_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transitionchild.$set(transitionchild_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(transitionchild.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(transitionchild.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(transitionchild, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(33:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let transitionroot;
  let current;
  const transitionroot_spread_levels = [
    /*$$props*/
    ctx[5],
    { as: (
      /*as*/
      ctx[0]
    ) },
    {
      use: [
        .../*use*/
        ctx[1],
        /*forwardEvents*/
        ctx[2]
      ]
    }
  ];
  let transitionroot_props = {
    $$slots: { default: [create_default_slot35] },
    $$scope: { ctx }
  };
  for (let i = 0; i < transitionroot_spread_levels.length; i += 1) {
    transitionroot_props = assign(transitionroot_props, transitionroot_spread_levels[i]);
  }
  transitionroot = new TransitionRoot_default({
    props: transitionroot_props,
    $$inline: true
  });
  transitionroot.$on(
    "introstart",
    /*introstart_handler*/
    ctx[7]
  );
  transitionroot.$on(
    "introend",
    /*introend_handler*/
    ctx[8]
  );
  transitionroot.$on(
    "outrostart",
    /*outrostart_handler*/
    ctx[9]
  );
  transitionroot.$on(
    "outroend",
    /*outroend_handler*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(transitionroot.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(transitionroot.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(transitionroot, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transitionroot_changes = dirty & /*$$props, as, use, forwardEvents*/
      39 ? get_spread_update(transitionroot_spread_levels, [
        dirty & /*$$props*/
        32 && get_spread_object(
          /*$$props*/
          ctx2[5]
        ),
        dirty & /*as*/
        1 && { as: (
          /*as*/
          ctx2[0]
        ) },
        dirty & /*use, forwardEvents*/
        6 && {
          use: [
            .../*use*/
            ctx2[1],
            /*forwardEvents*/
            ctx2[2]
          ]
        }
      ]) : {};
      if (dirty & /*$$scope*/
      32768) {
        transitionroot_changes.$$scope = { dirty, ctx: ctx2 };
      }
      transitionroot.$set(transitionroot_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(transitionroot.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(transitionroot.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(transitionroot, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(21:0) {#if !hasTransition && hasOpen}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(34:2) <TransitionChild     {...$$props}     {as}     use={[...use, forwardEvents]}     on:introstart     on:introend     on:outrostart     on:outroend   >",
    ctx
  });
  return block;
}
function create_default_slot35(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot35.name,
    type: "slot",
    source: "(22:2) <TransitionRoot     {...$$props}     {as}     use={[...use, forwardEvents]}     on:introstart     on:introend     on:outrostart     on:outroend   >",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*hasTransition*/
    ctx2[3] && /*hasOpen*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransitionChildWrapper", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component(), ["introstart", "introend", "outrostart", "outroend"]);
  let { as = "div" } = $$props;
  let { use = [] } = $$props;
  let hasTransition = hasTransitionContext();
  let hasOpen = hasOpenClosed();
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introstart_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    hasOpenClosed,
    TransitionChild: TransitionChild_default,
    TransitionRoot: TransitionRoot_default,
    forwardEventsBuilder,
    get_current_component,
    hasTransitionContext,
    forwardEvents,
    as,
    use,
    hasTransition,
    hasOpen
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("hasTransition" in $$props)
      $$invalidate(3, hasTransition = $$new_props.hasTransition);
    if ("hasOpen" in $$props)
      $$invalidate(4, hasOpen = $$new_props.hasOpen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    as,
    use,
    forwardEvents,
    hasTransition,
    hasOpen,
    $$props,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    introstart_handler_1,
    introend_handler_1,
    outrostart_handler_1,
    outroend_handler_1,
    $$scope
  ];
}
var TransitionChildWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { as: 0, use: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransitionChildWrapper",
      options,
      id: create_fragment42.name
    });
  }
  get as() {
    throw new Error("<TransitionChildWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<TransitionChildWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<TransitionChildWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TransitionChildWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransitionChildWrapper_default = TransitionChildWrapper;
export {
  Dialog_default as Dialog,
  Description_default as DialogDescription,
  DialogOverlay_default as DialogOverlay,
  DialogTitle_default as DialogTitle,
  Disclosure_default as Disclosure,
  DisclosureButton_default as DisclosureButton,
  DisclosurePanel_default as DisclosurePanel,
  Listbox_default as Listbox,
  ListboxButton_default as ListboxButton,
  ListboxLabel_default as ListboxLabel,
  ListboxOption_default as ListboxOption,
  ListboxOptions_default as ListboxOptions,
  Menu_default as Menu,
  MenuButton_default as MenuButton,
  MenuItem_default as MenuItem,
  MenuItems_default as MenuItems,
  Popover_default as Popover,
  PopoverButton_default as PopoverButton,
  PopoverGroup_default as PopoverGroup,
  PopoverOverlay_default as PopoverOverlay,
  PopoverPanel_default as PopoverPanel,
  Portal_default as Portal,
  PortalGroup_default as PortalGroup,
  RadioGroup_default as RadioGroup,
  Description_default as RadioGroupDescription,
  Label_default as RadioGroupLabel,
  RadioGroupOption_default as RadioGroupOption,
  Switch_default as Switch,
  Description_default as SwitchDescription,
  SwitchGroup_default as SwitchGroup,
  Label_default as SwitchLabel,
  Tab_default as Tab,
  TabGroup_default as TabGroup,
  TabList_default as TabList,
  TabPanel_default as TabPanel,
  TabPanels_default as TabPanels,
  TransitionRoot_default as Transition,
  TransitionChildWrapper_default as TransitionChild,
  TransitionRoot_default as TransitionRoot
};
//# sourceMappingURL=@rgossiaux_svelte-headlessui.js.map
